{"version":3,"names":[],"mappings":"","sources":["di4es.js"],"sourcesContent":["/* di4js (ver. 2.0.0). https://github.com/flamencist/di4es */\r\n\r\n(function () {\r\n\r\n  \"use strict\";\r\n\r\n  var exports = {};\r\n\r\n  if (!(\"version\" in exports)) {\r\n    exports.version = \"2.0.0\";\r\n  }\r\n\r\n  //http://stackoverflow.com/questions/6598945/detect-if-function-is-native-to-browser\r\nvar isFuncNative = function isFuncNative(f) {\r\n    return !!f && (typeof f).toLowerCase() === \"function\" &&\r\n        //jshint maxlen=300\r\n        (/^\\s*function\\s*(\\b[a-z$_][a-z0-9$_]*\\b)*\\s*\\((|([a-z$_][a-z0-9$_]*)(\\s*,[a-z$_][a-z0-9$_]*)*)\\)\\s*\\{\\s*\\[native code\\]\\s*}\\s*$/i.test(String(f))\r\n        || f === Function.prototype);\r\n};\r\n\r\nvar shim = {\r\n    object: {},\r\n    _: {}\r\n};\r\n\r\n//noinspection Eslint\r\nshim._.function_toString = Function.prototype.toString;\r\nvar call = Function.call;\r\n\r\nfunction uncurryThis(f) {\r\n    return function () {\r\n        return call.apply(f, arguments);\r\n    };\r\n}\r\n\r\nvar prototypeOfObject = Object.prototype;\r\nshim.object.prototype = prototypeOfObject;\r\nvar owns = uncurryThis(prototypeOfObject.hasOwnProperty);\r\nvar isEnumerable = uncurryThis(prototypeOfObject.propertyIsEnumerable);\r\nvar toStr = uncurryThis(prototypeOfObject.toString);\r\n\r\n// If JS engine supports accessors creating shortcuts.\r\nvar defineGetter;\r\nvar defineSetter;\r\nvar lookupGetter;\r\nvar lookupSetter;\r\nvar supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\");\r\nif (supportsAccessors) {\r\n    /* eslint-disable no-underscore-dangle */\r\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\r\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\r\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\r\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\r\n    /* eslint-enable no-underscore-dangle */\r\n}\r\n\r\n// Having a toString local variable name breaks in Opera so use to_string.\r\nvar to_string = prototypeOfObject.toString;\r\n\r\nvar isFunction = function (val) {\r\n    return to_string.call(val) === \"[object Function]\";\r\n};\r\nvar isArray = function isArray(obj) {\r\n    return to_string.call(obj) === \"[object Array]\";\r\n};\r\nvar isString = function isString(obj) {\r\n    return to_string.call(obj) === \"[object String]\";\r\n};\r\nvar isArguments = function isArguments(value) {\r\n    var str = to_string.call(value);\r\n    var isArgs = str === \"[object Arguments]\";\r\n    if (!isArgs) {\r\n        isArgs = !isArray(value) &&\r\n            value !== null &&\r\n            typeof value === \"object\" &&\r\n            typeof value.length === \"number\" &&\r\n            value.length >= 0 &&\r\n            isFunction(value.callee);\r\n    }\r\n    return isArgs;\r\n};\r\n\r\n\r\n// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\r\nvar hasDontEnumBug = !({\"toString\": null}).propertyIsEnumerable(\"toString\"),\r\n    hasProtoEnumBug = function () {\r\n    }.propertyIsEnumerable(\"prototype\"),\r\n    hasStringEnumBug = !owns(\"x\", \"0\"),\r\n    dontEnums = [\r\n        \"toString\",\r\n        \"toLocaleString\",\r\n        \"valueOf\",\r\n        \"hasOwnProperty\",\r\n        \"isPrototypeOf\",\r\n        \"propertyIsEnumerable\",\r\n        \"constructor\"\r\n    ],\r\n    dontEnumsLength = dontEnums.length;\r\n\r\nvar toObject = function (o) {\r\n    /*jshint eqnull: true */\r\n    //noinspection Eslint\r\n    if (o == null) { // this matches both null and undefined\r\n        throw new TypeError(\"can\\\"t convert \" + o + \" to object\");\r\n    }\r\n    return Object(o);\r\n};\r\n\r\nshim._.indexOf = Array.prototype.indexOf && isFuncNative(Array.prototype.indexOf) ?\r\n    function (arr, sought) {\r\n        return arr.indexOf(sought);\r\n    } :\r\n    function indexOf(arr, sought /*, fromIndex */) {\r\n        var length = arr.length >>> 0;\r\n\r\n        if (!length) {\r\n            return -1;\r\n        }\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            if (i in arr && arr[i] === sought) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n\r\nvar array_forEach = function forEach(arr, fun) {\r\n    var thisp = arguments[2],\r\n        i = -1,\r\n        length = arr.length >>> 0;\r\n\r\n    // If no callback function or if callback is not a callable function\r\n    if (!isFunction(fun)) {\r\n        throw new TypeError(); // TODO message\r\n    }\r\n\r\n    while (++i < length) {\r\n        if (i in arr) {\r\n            // Invoke the callback function with call, passing arguments:\r\n            // context, property value, property key, thisArg object\r\n            // context\r\n            fun.call(thisp, arr[i], i, arr);\r\n        }\r\n    }\r\n};\r\n\r\nshim.object.keys = Object.keys && isFuncNative(Object.keys) ? Object.keys : function keys(object) {\r\n    var isFn = isFunction(object),\r\n        isArgs = isArguments(object),\r\n        isObject = object !== null && typeof object === \"object\",\r\n        isStr = isObject && isString(object);\r\n\r\n    if (!isObject && !isFn && !isArgs) {\r\n        throw new TypeError(\"Object.keys called on a non-object\");\r\n    }\r\n\r\n    var theKeys = [];\r\n    var skipProto = hasProtoEnumBug && isFn;\r\n    if ((isStr && hasStringEnumBug) || isArgs) {\r\n        for (var i = 0; i < object.length; ++i) {\r\n            theKeys.push(String(i));\r\n        }\r\n    }\r\n\r\n    if (!isArgs) {\r\n        for (var name in object) {\r\n            if (!(skipProto && name === \"prototype\") && owns(object, name)) {\r\n                theKeys.push(String(name));\r\n            }\r\n        }\r\n    }\r\n\r\n    if (hasDontEnumBug) {\r\n        var ctor = object.constructor,\r\n            skipConstructor = ctor && ctor.prototype === object;\r\n        for (var j = 0; j < dontEnumsLength; j++) {\r\n            var dontEnum = dontEnums[j];\r\n            if (!(skipConstructor && dontEnum === \"constructor\") && owns(object, dontEnum)) {\r\n                theKeys.push(dontEnum);\r\n            }\r\n        }\r\n    }\r\n    return theKeys;\r\n};\r\n\r\nshim.object.getPrototypeOf = Object.getPrototypeOf && isFuncNative(Object.getPrototypeOf) ? Object.getPrototypeOf :\r\n    function getPrototypeOf(object) {\r\n        /* jshint ignore:start */\r\n        var proto = object.__proto__;\r\n        /* jshint ignore:end */\r\n        if (proto || proto === null) {\r\n            return proto;\r\n        } else if (toStr(object.constructor) === \"[object Function]\") {\r\n            return object.constructor.prototype;\r\n        } else if (object instanceof Object) {\r\n            return prototypeOfObject;\r\n        } else {\r\n            // Correctly return null for Objects created with `Object.create(null)`\r\n            // (shammed or native) or `{ __proto__: null}`.  Also returns null for\r\n            // cross-realm objects on browsers that lack `__proto__` support (like\r\n            // IE <11), but that\"s the best we can do.\r\n            return null;\r\n        }\r\n    };\r\n\r\nvar doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {\r\n    try {\r\n        object.sentinel = 0;\r\n        return Object.getOwnPropertyDescriptor(object, \"sentinel\").value === 0;\r\n    } catch (exception) {\r\n        return false;\r\n    }\r\n};\r\n\r\n// check whether getOwnPropertyDescriptor works if it\"s given. Otherwise, shim partially.\r\nvar getOwnPropertyDescriptorFallback;\r\nif (Object.defineProperty) {\r\n    var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});\r\n    var getOwnPropertyDescriptorWorksOnDom = typeof document === \"undefined\" ||\r\n        doesGetOwnPropertyDescriptorWork(document.createElement(\"div\"));\r\n    if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {\r\n        getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;\r\n    }\r\n}\r\n\r\nvar ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a non-object: \";\r\n\r\n/* eslint-disable no-proto */\r\nshim.object.getOwnPropertyDescriptor =\r\n    (Object.getOwnPropertyDescriptor && getOwnPropertyDescriptorFallback) && isFuncNative(Object.getOwnPropertyDescriptor) ?\r\n        Object.getOwnPropertyDescriptor :\r\n        function getOwnPropertyDescriptor(object, property) {\r\n            if ((typeof object !== \"object\" && typeof object !== \"function\") || object === null) {\r\n                throw new TypeError(ERR_NON_OBJECT + object);\r\n            }\r\n\r\n            // make a valiant attempt to use the real getOwnPropertyDescriptor\r\n            // for I8\"s DOM elements.\r\n            if (getOwnPropertyDescriptorFallback) {\r\n                try {\r\n                    return getOwnPropertyDescriptorFallback.call(Object, object, property);\r\n                } catch (exception) {\r\n                    // try the shim if the real one doesn't work\r\n                }\r\n            }\r\n\r\n            var descriptor;\r\n\r\n            // If object does not owns property return undefined immediately.\r\n            if (!owns(object, property)) {\r\n                return descriptor;\r\n            }\r\n\r\n            // If object has a property then it\"s for sure `configurable`, and\r\n            // probably `enumerable`. Detect enumerability though.\r\n            descriptor = {\r\n                enumerable: isEnumerable(object, property),\r\n                configurable: true\r\n            };\r\n\r\n            // If JS engine supports accessor properties then property may be a\r\n            // getter or setter.\r\n            if (supportsAccessors) {\r\n                // Unfortunately `__lookupGetter__` will return a getter even\r\n                // if object has own non getter property along with a same named\r\n                // inherited getter. To avoid misbehavior we temporary remove\r\n                // `__proto__` so that `__lookupGetter__` will return getter only\r\n                // if it\"s owned by an object.\r\n                /* jshint ignore:start */\r\n                var prototype = object.__proto__;\r\n                /* jshint ignore:end */\r\n\r\n\r\n                var notPrototypeOfObject = object !== prototypeOfObject;\r\n                // avoid recursion problem, breaking in Opera Mini when\r\n                // Object.getOwnPropertyDescriptor(Object.prototype, \"toString\")\r\n                // or any other Object.prototype accessor\r\n                if (notPrototypeOfObject) {\r\n                    /* jshint ignore:start */\r\n                    object.__proto__ = prototypeOfObject;\r\n                    /* jshint ignore:end */\r\n                }\r\n\r\n                var getter = lookupGetter(object, property);\r\n                var setter = lookupSetter(object, property);\r\n\r\n                if (notPrototypeOfObject) {\r\n                    // Once we have getter and setter we can put values back.\r\n                    object.__proto__ = prototype; //jshint ignore:line\r\n                }\r\n\r\n                if (getter || setter) {\r\n                    if (getter) {\r\n                        descriptor.get = getter;\r\n                    }\r\n                    if (setter) {\r\n                        descriptor.set = setter;\r\n                    }\r\n                    // If it was accessor property we\"re done and return here\r\n                    // in order to avoid adding `value` to the descriptor.\r\n                    return descriptor;\r\n                }\r\n            }\r\n\r\n            // If we got this far we know that object has an own property that is\r\n            // not an accessor so we set it as a value and return descriptor.\r\n            descriptor.value = object[property];\r\n            descriptor.writable = true;\r\n            return descriptor;\r\n        };\r\n/* eslint-enable no-proto */\r\n\r\nshim.object.getOwnPropertyNames = Object.getOwnPropertyNames && isFuncNative(Object.getOwnPropertyNames) ?\r\n    Object.getOwnPropertyNames :\r\n    function getOwnPropertyNames(object) {\r\n        return shim.object.keys(object);\r\n    };\r\n\r\nif (!Object.create || !isFuncNative(Object.create)) {\r\n\r\n    // Contributed by Brandon Benvie, October, 2012\r\n    var createEmpty;\r\n    var supportsProto = !({__proto__: null} instanceof Object);//jshint ignore:line\r\n    // the following produces false positives\r\n    // in Opera Mini => not a reliable check\r\n    // Object.prototype.__proto__ === null\r\n\r\n    // Check for document.domain and active x support\r\n    // No need to use active x approach when document.domain is not set\r\n    // see https://github.com/es-shims/es5-shim/issues/150\r\n    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\r\n    /* global ActiveXObject */\r\n    var shouldUseActiveX = function shouldUseActiveX() {\r\n        // return early if document.domain not set\r\n        if (!document.domain) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            return !!new ActiveXObject(\"htmlfile\");\r\n        } catch (exception) {\r\n            return false;\r\n        }\r\n    };\r\n\r\n    // This supports IE8 when document.domain is used\r\n    // see https://github.com/es-shims/es5-shim/issues/150\r\n    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\r\n    var getEmptyViaActiveX = function getEmptyViaActiveX() {\r\n        var empty;\r\n        var xDoc;\r\n\r\n        xDoc = new ActiveXObject(\"htmlfile\");\r\n\r\n        xDoc.write(\"<script><\\/script>\");\r\n        xDoc.close();\r\n\r\n        empty = xDoc.parentWindow.Object.prototype;\r\n        xDoc = null;\r\n\r\n        return empty;\r\n    };\r\n\r\n    // The original implementation using an iframe\r\n    // before the activex approach was added\r\n    // see https://github.com/es-shims/es5-shim/issues/150\r\n    var getEmptyViaIFrame = function getEmptyViaIFrame() {\r\n        var iframe = document.createElement(\"iframe\");\r\n        var parent = document.body || document.documentElement;\r\n        var empty;\r\n\r\n        iframe.style.display = \"none\";\r\n        parent.appendChild(iframe);\r\n        /* jshint ignore:start */\r\n        iframe.src = \"javascript:\";\r\n        /* jshint ignore:end */\r\n\r\n        empty = iframe.contentWindow.Object.prototype;\r\n        parent.removeChild(iframe);\r\n        iframe = null;\r\n\r\n        return empty;\r\n    };\r\n\r\n    /* global document */\r\n    if (supportsProto || typeof document === \"undefined\") {\r\n        createEmpty = function () {\r\n            return {__proto__: null}; //jshint ignore:line\r\n        };\r\n    } else {\r\n        // In old IE __proto__ can\"t be used to manually set `null`, nor does\r\n        // any other method exist to make an object that inherits from nothing,\r\n        // aside from Object.prototype itself. Instead, create a new global\r\n        // object and *steal* its Object.prototype and strip it bare. This is\r\n        // used as the prototype to create nullary objects.\r\n        createEmpty = function () {\r\n            // Determine which approach to use\r\n            // see https://github.com/es-shims/es5-shim/issues/150\r\n            var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();\r\n\r\n            delete empty.constructor;\r\n            delete empty.hasOwnProperty;\r\n            delete empty.propertyIsEnumerable;\r\n            delete empty.isPrototypeOf;\r\n            delete empty.toLocaleString;\r\n            delete empty.toString;\r\n            delete empty.valueOf;\r\n\r\n            var Empty = function Empty() {\r\n            };\r\n            Empty.prototype = empty;\r\n            // short-circuit future calls\r\n            createEmpty = function () {\r\n                return new Empty();\r\n            };\r\n            return new Empty();\r\n        };\r\n    }\r\n\r\n    shim.object.create = function create(prototype, properties) {\r\n\r\n        var object;\r\n        var Type = function Type() {\r\n        }; // An empty constructor.\r\n\r\n        if (prototype === null) {\r\n            object = createEmpty();\r\n        } else {\r\n            if (typeof prototype !== \"object\" && typeof prototype !== \"function\") {\r\n                // In the native implementation `parent` can be `null`\r\n                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)\r\n                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`\r\n                // like they are in modern browsers. Using `Object.create` on DOM elements\r\n                // is...err...probably inappropriate, but the native version allows for it.\r\n                throw new TypeError(\"Object prototype may only be an Object or null\"); // same msg as Chrome\r\n            }\r\n            Type.prototype = prototype;\r\n            object = new Type();\r\n            // IE has no built-in implementation of `Object.getPrototypeOf`\r\n            // neither `__proto__`, but this manually setting `__proto__` will\r\n            // guarantee that `Object.getPrototypeOf` will work as expected with\r\n            // objects created using `Object.create`\r\n            /* eslint-disable no-proto */\r\n            object.__proto__ = prototype;//jshint ignore:line\r\n            /* eslint-enable no-proto */\r\n        }\r\n\r\n        if (properties !== void 0) {\r\n            shim.object.defineProperties(object, properties);\r\n        }\r\n\r\n        return object;\r\n    };\r\n} else {\r\n    shim.object.create = Object.create;\r\n}\r\n\r\nvar doesDefinePropertyWork = function doesDefinePropertyWork(object) {\r\n    try {\r\n        Object.defineProperty(object, \"sentinel\", {});\r\n        return \"sentinel\" in object;\r\n    } catch (exception) {\r\n        return false;\r\n    }\r\n};\r\n\r\n// check whether defineProperty works if it\"s given. Otherwise,\r\n// shim partially.\r\nvar definePropertyFallback;\r\nvar definePropertiesFallback;\r\nif (Object.defineProperty && isFuncNative(Object.defineProperty)) {\r\n    var definePropertyWorksOnObject = doesDefinePropertyWork({});\r\n    var definePropertyWorksOnDom = typeof document === \"undefined\" ||\r\n        doesDefinePropertyWork(document.createElement(\"div\"));\r\n    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\r\n        definePropertyFallback = Object.defineProperty;\r\n        definePropertiesFallback = Object.defineProperties;\r\n    }\r\n}\r\n\r\nif (!Object.defineProperty || definePropertyFallback || !isFuncNative(Object.defineProperty)) {\r\n    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\r\n    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \";\r\n    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined on this javascript engine\";\r\n\r\n    shim.object.defineProperty = function defineProperty(object, property, descriptor) {\r\n        if ((typeof object !== \"object\" && typeof object !== \"function\") || object === null) {\r\n            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\r\n        }\r\n        if ((typeof descriptor !== \"object\" && typeof descriptor !== \"function\") || descriptor === null) {\r\n            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\r\n        }\r\n        // make a valiant attempt to use the real defineProperty\r\n        // for I8\"s DOM elements.\r\n        if (definePropertyFallback) {\r\n            try {\r\n                return definePropertyFallback.call(Object, object, property, descriptor);\r\n            } catch (exception) {\r\n                // try the shim if the real one doesn't work\r\n            }\r\n        }\r\n\r\n        // If it\"s a data property.\r\n        if (\"value\" in descriptor) {\r\n\r\n            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {\r\n                // As accessors are supported only on engines implementing\r\n                // `__proto__` we can safely override `__proto__` while defining\r\n                // a property to make sure that we don\"t hit an inherited\r\n                // accessor.\r\n                /* jshint ignore:start */\r\n                var prototype = object.__proto__;\r\n                object.__proto__ = prototypeOfObject;\r\n                // Deleting a property anyway since getter / setter may be\r\n                // defined on object itself.\r\n                delete object[property];\r\n                object[property] = descriptor.value;\r\n                // Setting original `__proto__` back now.\r\n                object.__proto__ = prototype;\r\n                /* jshint ignore:end */\r\n            } else {\r\n                object[property] = descriptor.value;\r\n            }\r\n        } else {\r\n            if (!supportsAccessors && ((\"get\" in descriptor) || (\"set\" in descriptor))) {\r\n                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\r\n            }\r\n            // If we got that far then getters and setters can be defined !!\r\n            if (\"get\" in descriptor) {\r\n                defineGetter(object, property, descriptor.get);\r\n            }\r\n            if (\"set\" in descriptor) {\r\n                defineSetter(object, property, descriptor.set);\r\n            }\r\n        }\r\n        return object;\r\n    };\r\n} else {\r\n    shim.object.defineProperty = Object.defineProperty;\r\n}\r\n\r\n// ES5 15.2.3.7\r\n// http://es5.github.com/#x15.2.3.7\r\nshim.object.defineProperties = Object.defineProperties && definePropertiesFallback && isFuncNative(Object.defineProperties) ?\r\n    Object.defineProperties :\r\n    function defineProperties(object, properties) {\r\n        // make a valiant attempt to use the real defineProperties\r\n        if (definePropertiesFallback) {\r\n            try {\r\n                return definePropertiesFallback.call(Object, object, properties);\r\n            } catch (exception) {\r\n                // try the shim if the real one doesn't work\r\n            }\r\n        }\r\n\r\n        array_forEach(shim.object.keys(properties), function (property) {\r\n            if (property !== \"__proto__\") {\r\n                shim.object.defineProperty(object, property, properties[property]);\r\n            }\r\n        });\r\n        return object;\r\n    };\r\n\r\n\r\n// ES5 15.2.3.8\r\n// http://es5.github.com/#x15.2.3.8\r\nshim.object.seal = Object.seal && isFuncNative(Object.seal) ? Object.seal :\r\n    function seal(object) {\r\n        if (toObject(object) !== object) {\r\n            throw new TypeError(\"Object.seal can only be called on Objects.\");\r\n        }\r\n        // this is misleading and breaks feature-detection, but\r\n        // allows \"securable\" code to \"gracefully\" degrade to working\r\n        // but insecure code.\r\n        return object;\r\n    };\r\n\r\n// ES5 15.2.3.9\r\n// http://es5.github.com/#x15.2.3.9\r\nshim.object.freeze = Object.freeze && isFuncNative(Object.freeze) ? Object.freeze :\r\n    function freeze(object) {\r\n        if (toObject(object) !== object) {\r\n            throw new TypeError(\"Object.freeze can only be called on Objects.\");\r\n        }\r\n        // this is misleading and breaks feature-detection, but\r\n        // allows \"securable\" code to \"gracefully\" degrade to working\r\n        // but insecure code.\r\n        return object;\r\n    };\r\n\r\n// detect a Rhino bug and patch it\r\ntry {\r\n    Object.freeze(function () {\r\n    });\r\n} catch (exception) {\r\n    shim.object.freeze = (function (freezeObject) {\r\n        return function freeze(object) {\r\n            if (typeof object === \"function\") {\r\n                return object;\r\n            } else {\r\n                return freezeObject(object);\r\n            }\r\n        };\r\n    }(shim.object.freeze));\r\n}\r\n\r\n// ES5 15.2.3.10\r\n// http://es5.github.com/#x15.2.3.10\r\nshim.object.preventExtensions = Object.preventExtensions && isFuncNative(Object.preventExtensions) ?\r\n    Object.preventExtensions : function preventExtensions(object) {\r\n    if (toObject(object) !== object) {\r\n        throw new TypeError(\"Object.preventExtensions can only be called on Objects.\");\r\n    }\r\n    // this is misleading and breaks feature-detection, but\r\n    // allows \"securable\" code to \"gracefully\" degrade to working\r\n    // but insecure code.\r\n    return object;\r\n};\r\n\r\nshim.object.isSealed = Object.isSealed && isFuncNative(Object.isSealed) ? Object.isSealed : function isSealed(object) {\r\n    if (toObject(object) !== object) {\r\n        throw new TypeError(\"Object.isSealed can only be called on Objects.\");\r\n    }\r\n    return false;\r\n};\r\n\r\n// ES5 15.2.3.12\r\n// http://es5.github.com/#x15.2.3.12\r\nshim.object.isFrozen = Object.isFrozen && isFuncNative(Object.isFrozen) ? Object.isFrozen : function isFrozen(object) {\r\n    if (toObject(object) !== object) {\r\n        throw new TypeError(\"Object.isFrozen can only be called on Objects.\");\r\n    }\r\n    return false;\r\n};\r\n\r\n// ES5 15.2.3.13\r\n// http://es5.github.com/#x15.2.3.13\r\nshim.object.isExtensible = Object.isExtensible && isFuncNative(Object.isExtensible) ? Object.isExtensible : function isExtensible(object) {\r\n    // 1. If Type(O) is not Object throw a TypeError exception.\r\n    if (toObject(object) !== object) {\r\n        throw new TypeError(\"Object.isExtensible can only be called on Objects.\");\r\n    }\r\n    // 2. Return the Boolean value of the [[Extensible]] internal property of O.\r\n    var name = \"\";\r\n    while (owns(object, name)) {\r\n        name += \"?\";\r\n    }\r\n    object[name] = true;\r\n    var returnValue = owns(object, name);\r\n    delete object[name];\r\n    return returnValue;\r\n};\r\n\r\n (function(exports, Object, _){\r\n\r\n\t var DependencyResolverException = function (message) {\r\n\t   this.name = \"DependencyResolverException\";\r\n\t   this.stack = null;\r\n\t   this.message = message || \"A dependency resolver exception has occurred.\";\r\n\t   var lines, i, tmp;\r\n\t   if ((typeof navigator !== \"undefined\" && navigator.userAgent.indexOf(\"Chrome\") !== -1) ||\r\n\t     (typeof navigator === \"undefined\")) {\r\n\t     lines = new Error().stack.split(\"\\n\");\r\n\t     if (lines && lines.length > 2) {\r\n\t       tmp = [];\r\n\t       for (i = 2; i < lines.length; i++) {\r\n\t         if (lines[i]) {\r\n\t           tmp.push(lines[i].trim());\r\n\t         }\r\n\t       }\r\n\t       this.stack = tmp.join(\"\\n\");\r\n\t     }\r\n\t   } else if (typeof navigator !== \"undefined\" && navigator.userAgent.indexOf(\"Firefox\") !== -1) {\r\n\t     lines = new Error().stack.split(\"\\n\");\r\n\t     if (lines && lines.length > 1) {\r\n\t       tmp = [];\r\n\t       for (i = 1; i < lines.length; i++) {\r\n\t         if (lines[i]) {\r\n\t           tmp.push(\"at \" + lines[i].trim().replace(\"@\", \" (\") + \")\");\r\n\t         }\r\n\t       }\r\n\t       this.stack = tmp.join(\"\\n\");\r\n\t     }\r\n\t   } else if (typeof navigator !== \"undefined\" && navigator.userAgent.indexOf(\"Trident\") !== -1) {\r\n\t     try {\r\n\t       throw new Error();\r\n\t     } catch (error) {\r\n\t       if (\"stack\" in error) {\r\n\t         lines = error.stack.split(\"\\n\");\r\n\t         if (lines && lines.length > 2) {\r\n\t           tmp = [];\r\n\t           for (i = 2; i < lines.length; i++) {\r\n\t             if (lines[i]) {\r\n\t               tmp.push(lines[i].trim());\r\n\t             }\r\n\t           }\r\n\t           this.stack = tmp.join(\"\\n\");\r\n\t         }\r\n\t       } else {\r\n\t         this.stack = \"\";\r\n\t       }\r\n\t     }\r\n\t   } else {\r\n\t     var error = new Error();\r\n\t     if (\"stack\" in error) {\r\n\t       this.stack = error.stack;\r\n\t     } else {\r\n\t       this.stack = \"\";\r\n\t     }\r\n\t   }\r\n\t   Object.defineProperty(this, \"name\", { enumerable: true });\r\n\t   Object.defineProperty(this, \"message\", { enumerable: true });\r\n\t   Object.defineProperty(this, \"stack\", { enumerable: true });\r\n\t   Object.seal(this);\r\n\t };\r\n\t \r\n\t DependencyResolverException.prototype = Object.create(Object.prototype, {\r\n\t   toString: {\r\n\t     value: function () {\r\n\t       var msg = this.name + \": \" + this.message;\r\n\t       if (this.stack) {\r\n\t         msg += \"\\n\\t\" + this.stack.replace(/\\n/g, \"\\n\\t\");\r\n\t       }\r\n\t       return msg;\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.seal(DependencyResolverException);\r\n\t Object.seal(DependencyResolverException.prototype);\r\n\t \r\n\t exports.DependencyResolverException = DependencyResolverException;\r\n\r\n\t /* global DependencyResolverException */\r\n\t var InstanceFactoryOptions = function (options) {\r\n\t   this.name = null;\r\n\t   this.type = null;\r\n\t   this.parameters = null;\r\n\t   if (options) {\r\n\t     for (var propertyName in options) {\r\n\t       if (propertyName in this) {\r\n\t         this[propertyName] = options[propertyName];\r\n\t       } else {\r\n\t         throw new DependencyResolverException(\"Class \\\"InstanceFactoryOptions\\\" doesn\\\"t have a property \\\"\" +\r\n\t           propertyName + \"\\\"\");\r\n\t       }\r\n\t     }\r\n\t   }\r\n\t   Object.defineProperty(this, \"name\", { enumerable: true });\r\n\t   Object.defineProperty(this, \"type\", { enumerable: true });\r\n\t   Object.defineProperty(this, \"parameters\", { enumerable: true });\r\n\t   Object.seal(this);\r\n\t };\r\n\t \r\n\t InstanceFactoryOptions.prototype = Object.create(Object.prototype, {\r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object InstanceFactoryOptions]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.seal(InstanceFactoryOptions);\r\n\t Object.seal(InstanceFactoryOptions.prototype);\r\n\t \r\n\t exports.InstanceFactoryOptions = InstanceFactoryOptions;\r\n\r\n\t \r\n\t var IInstanceFactory = Object.create(Object.prototype, {\r\n\t \r\n\t   create: {\r\n\t     value: function (options) {}, //eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object IInstanceFactory]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.freeze(IInstanceFactory);\r\n\t \r\n\t exports.IInstanceFactory = IInstanceFactory;\r\n\r\n\t /* global DependencyResolverException */\r\n\t var InstanceFactory = function () {\r\n\t   Object.seal(this);\r\n\t };\r\n\t \r\n\t InstanceFactory.prototype = Object.create(Object.prototype, {\r\n\t \r\n\t   create: {\r\n\t     value: function (options) {\r\n\t       if (!options) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"options\\\" is not set\");\r\n\t       }\r\n\t       if (\"type\" in options && !options.type) {\r\n\t         throw new DependencyResolverException(\"Factory can't create object, because type is not set\");\r\n\t       }\r\n\t       if (typeof options.type !== \"function\") {\r\n\t         throw new DependencyResolverException(\"Factory can't create object, because given type is not a function\");\r\n\t       }\r\n\t       if (options.type === Number || options.type === Date || options.type === Boolean || options.type === String ||\r\n\t         options.type === Array || options.type === Function || options.type === RegExp) {\r\n\t         throw new DependencyResolverException(\"Basic type can not be instantiated using a factory\");\r\n\t       }\r\n\t       var instance = null;\r\n\t       if (options.parameters && options.parameters.length > 0) {\r\n\t         instance = Object.create(options.type.prototype);\r\n\t         options.type.apply(instance, options.parameters);\r\n\t       } else {\r\n\t         instance = new options.type();\r\n\t       }\r\n\t       return instance;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object InstanceFactory]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.seal(InstanceFactory);\r\n\t Object.seal(InstanceFactory.prototype);\r\n\t \r\n\t exports.InstanceFactory = InstanceFactory;\r\n\r\n\t var INameTransformer = Object.create(Object.prototype, {\r\n\t \r\n\t   transform: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object INameTransformer]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.freeze(INameTransformer);\r\n\t \r\n\t exports.INameTransformer = INameTransformer;\r\n\r\n\t /* global DependencyResolverException */\r\n\t var NameTransformer = function () {\r\n\t   Object.seal(this);\r\n\t };\r\n\t \r\n\t NameTransformer.prototype = Object.create(Object.prototype, {\r\n\t \r\n\t   transform: {\r\n\t     value: function (name) {\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"transform\\\"\");\r\n\t       }\r\n\t       return name;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object NameTransformer]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.seal(NameTransformer);\r\n\t Object.seal(NameTransformer.prototype);\r\n\t \r\n\t exports.NameTransformer = NameTransformer;\r\n\r\n\t var IDependencyResolver = Object.create(Object.prototype, {\r\n\t \r\n\t   isAutowired: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   autowired: {\r\n\t     value: function (value) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   register: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   as: {\r\n\t     value: function (type) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   instance: {\r\n\t     value: function (instance) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   asSingleton: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   withConstructor: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   param: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   withProperties: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   prop: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   val: {\r\n\t     value: function (instance) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   ref: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   setFactory: {\r\n\t     value: function (factory) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   create: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   inject: {\r\n\t     value: function (func, name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   contains: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   resolve: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   getDefaultFactory: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   setDefaultFactory: {\r\n\t     value: function (factory) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   getNameTransformer: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   setNameTransformer: {\r\n\t     value: function (transformer) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   getRegistration: {\r\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   dispose: {\r\n\t     value: function () {},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object IDependencyResolver]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.freeze(IDependencyResolver);\r\n\t \r\n\t exports.IDependencyResolver = IDependencyResolver;\r\n\r\n\t /* global DependencyResolverException, InstanceFactory, NameTransformer, InstanceFactoryOptions, debug, index, args */\r\n\t var DependencyResolver = function (parent) {\r\n\t   this.__parent = parent;\r\n\t   this.__defaultFactory = null;\r\n\t   this.__nameTransformer = null;\r\n\t   this.__autowired = false;\r\n\t   this.__container = null;\r\n\t   this.__registration = null;\r\n\t   this.__withProperties = false;\r\n\t   this.__withConstructor = false;\r\n\t   this.__parameter = null;\r\n\t   this.__property = null;\r\n\t   this.__function = null;\r\n\t   if (parent) {\r\n\t     this.__autowired = parent.isAutowired();\r\n\t   }\r\n\t   Object.defineProperty(this, \"__parent\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__defaultFactory\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__nameTransformer\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__autowired\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__container\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__registration\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__withProperties\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__withConstructor\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__parameter\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__property\", { enumerable: false });\r\n\t   Object.defineProperty(this, \"__function\", { enumerable: false });\r\n\t   Object.seal(this);\r\n\t };\r\n\t \r\n\t DependencyResolver.prototype = Object.create(Object.prototype, {\r\n\t \r\n\t   isAutowired: {\r\n\t \tvalue: function(){\r\n\t \t\treturn this.__autowired;\r\n\t \t},\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   autowired: {\r\n\t     value: function (value) {\r\n\t       if (value === undefined || value === null) {\r\n\t         value = true;\r\n\t       }\r\n\t       if (typeof value !== \"boolean\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"value\\\" passed to the method \\\"autowired\\\" has to \" +\r\n\t           \"be a \\\"boolean\\\"\");\r\n\t       }\r\n\t       this.__autowired = value;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   register: {\r\n\t     value: function (name) {\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"register\\\"\");\r\n\t       }\r\n\t       if (typeof name !== \"string\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"register\\\" has to be \" +\r\n\t           \"a \\\"string\\\"\");\r\n\t       }\r\n\t       if (!this.__container) {\r\n\t         this.__container = Object.create(null);\r\n\t       }\r\n\t       this.__registration = {\r\n\t         name: name,\r\n\t         singleton: false,\r\n\t         type: null,\r\n\t         instance: null,\r\n\t         factory: null,\r\n\t         dependencies: null\r\n\t       };\r\n\t       if (!(name in this.__container)) {\r\n\t         this.__container[name] = this.__registration;\r\n\t       } else {\r\n\t         if (!(this.__container[name] instanceof Array)) { \r\n\t           this.__container[name] = [ this.__container[name] ];\r\n\t         }\r\n\t         this.__container[name].push(this.__registration);\r\n\t       }\r\n\t       this.__withConstructor = false;\r\n\t       this.__withProperties = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   as: {\r\n\t     value: function (type) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!type) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"type\\\" is not passed to the method \\\"as\\\" for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (typeof type !== \"function\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"type\\\" passed to the method \\\"as\\\" has to be a \\\"function\\\" \" +\r\n\t           \"for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       this.__registration.instance = null;\r\n\t       this.__registration.type = type;\r\n\t       this.__registration.singleton = false;\r\n\t       this.__registration.dependencies = {\r\n\t         parameters: [],\r\n\t         properties: [],\r\n\t         functions: []\r\n\t       };\r\n\t       this.__withConstructor = false;\r\n\t       this.__withProperties = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   instance: {\r\n\t     value: function (instance) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (instance === null || instance === undefined) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"instance\\\" is not passed to the method \\\"instance\\\" for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       this.__registration.instance = instance;\r\n\t       this.__registration.type = null;\r\n\t       this.__registration.factory = null;\r\n\t       this.__registration.singleton = true;\r\n\t       this.__registration.dependencies = null;\r\n\t       this.__withConstructor = false;\r\n\t       this.__withProperties = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   asSingleton: {\r\n\t     value: function () {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" +\r\n\t           this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       this.__registration.singleton = true;\r\n\t       this.__withConstructor = false;\r\n\t       this.__withProperties = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   withConstructor: {\r\n\t     value: function () {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" +\r\n\t           this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       this.__withConstructor = true;\r\n\t       this.__withProperties = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   param: {\r\n\t     value: function (name) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       var parameters = null,\r\n\t           parameter = null,\r\n\t           index;\r\n\t       if (this.__withConstructor) {\r\n\t         parameters = this.__registration.dependencies.parameters;\r\n\t         if (this.__autowired && (name === undefined || name === null)) {\r\n\t           throw new DependencyResolverException(\"Parameter \\\"name\\\" has to be passed to the method, when dependency \" +\r\n\t             \"container has option \\\"autowired\\\" enabled\");\r\n\t         }\r\n\t         parameter = this.__findParameter(name, parameters, this.__registration);\r\n\t       } else if (this.__withProperties) {\r\n\t         if (!this.__function) {\r\n\t           throw new DependencyResolverException(\"Function is not defined\");\r\n\t         }\r\n\t         parameters = this.__function.parameters;\r\n\t         parameter = this.__findParameter(name, this.__function.parameters, this.__registration);\r\n\t       } else {\r\n\t         throw new DependencyResolverException(\"Invocation of method \\\"withConstructor\\\" or \\\"withProperties\\\" \" +\r\n\t           \"is missing for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (!parameter) {\r\n\t         parameter = {\r\n\t           index: index,\r\n\t           name: name,\r\n\t           value: undefined,\r\n\t           reference: undefined\r\n\t         };\r\n\t         parameters.push(parameter);\r\n\t       }\r\n\t       this.__parameter = parameter;\r\n\t       this.__property = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   withProperties: {\r\n\t     value: function () {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       this.__withProperties = true;\r\n\t       this.__withConstructor = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   prop: {\r\n\t     value: function (name) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"prop\\\" for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (typeof name !== \"string\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"prop\\\" has to be\" +\r\n\t           \" a \\\"string\\\" for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (!this.__withProperties) {\r\n\t         throw new DependencyResolverException(\"Invocation of method \\\"withProperties\\\" is missing for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       var properties = this.__registration.dependencies.properties,\r\n\t           property = null;\r\n\t       for (var i = 0; i < properties.length; i++) {\r\n\t         if (properties[i].name === name) {\r\n\t           property = properties[i];\r\n\t           break;\r\n\t         }\r\n\t       }\r\n\t       if (!property) {\r\n\t         property = {\r\n\t           name: name,\r\n\t           value: undefined,\r\n\t           reference: undefined\r\n\t         };\r\n\t         properties.push(property);\r\n\t       }\r\n\t       this.__parameter = null;\r\n\t       this.__property = property;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   func: {\r\n\t     value: function (name) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"func\\\" for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (typeof name !== \"string\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"func\\\" has to be\" +\r\n\t           \" a \\\"string\\\" for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (!this.__withProperties) {\r\n\t         throw new DependencyResolverException(\"Invocation of method \\\"withProperties\\\" is missing for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       var functions = this.__registration.dependencies.functions,\r\n\t           func = null;\r\n\t       for (var i = 0; i < functions.length; i++) {\r\n\t         if (functions[i].name === name) {\r\n\t           func = functions[i];\r\n\t           break;\r\n\t         }\r\n\t       }\r\n\t       if (!func) {\r\n\t         func = {\r\n\t           name: name,\r\n\t           parameters: []\r\n\t         };\r\n\t         functions.push(func);\r\n\t       }\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = func;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   val: {\r\n\t     value: function (instance) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (instance === null || instance === undefined) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"instance\\\" is not passed to the method \\\"val\\\"\");\r\n\t       }\r\n\t       if (!this.__withProperties && !this.__withConstructor) {\r\n\t         throw new DependencyResolverException(\"Invocation of method withConstructor\\\" or \\\"withProperties\\\" \" +\r\n\t           \"is missing\");\r\n\t       }\r\n\t       if (this.__withConstructor && !this.__parameter) {\r\n\t         throw new DependencyResolverException(\"Parameter is not defined\");\r\n\t       }\r\n\t       if (this.__withProperties && !this.__parameter && !this.__property) {\r\n\t         throw new DependencyResolverException(\"Parameter or property is not defined\");\r\n\t       }\r\n\t       if (this.__parameter) {\r\n\t         this.__parameter.value = instance;\r\n\t         this.__parameter.reference = undefined;\r\n\t       } else if (this.__property) {\r\n\t         this.__property.value = instance;\r\n\t         this.__property.reference = undefined;\r\n\t       }\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   ref: {\r\n\t     value: function (name) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"ref\\\" for \" +\r\n\t           \"registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (typeof name !== \"string\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"ref\\\" has to \" +\r\n\t           \"be a \\\"string\\\" for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (!this.__withProperties && !this.__withConstructor) {\r\n\t         throw new DependencyResolverException(\"Invocation of method \\\"withConstructor\\\" or \\\"withProperties\\\" \" +\r\n\t           \"is missing for registration \\\"\" + this.__registration.name + \"\\\"\");\r\n\t       }\r\n\t       if (this.__withConstructor && !this.__parameter) {\r\n\t         throw new DependencyResolverException(\"Parameter is not defined\");\r\n\t       }\r\n\t       if (this.__withProperties && !this.__parameter && !this.__property) {\r\n\t         throw new DependencyResolverException(\"Parameter or property is not defined\");\r\n\t       }\r\n\t       if (!this.contains(name)) {\r\n\t         throw new DependencyResolverException(\"Type or instance is not registered with name \\\"\" + name + \"\\\"\");\r\n\t       }\r\n\t       if (this.__parameter) {\r\n\t         this.__parameter.value = undefined;\r\n\t         this.__parameter.reference = name;\r\n\t       } else if (this.__property) {\r\n\t         this.__property.value = undefined;\r\n\t         this.__property.reference = name;\r\n\t       }\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   setFactory: {\r\n\t     value: function (factory) {\r\n\t       if (!this.__registration) {\r\n\t         throw new DependencyResolverException(\"Registration's name is not defined\");\r\n\t       }\r\n\t       if (!factory) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"factory\\\" is not passed to the method \\\"setFactory\\\"\");\r\n\t       }\r\n\t       if (typeof factory !== \"function\" && typeof factory !== \"object\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"factory\\\" passed to the method \\\"setFactory\\\" has to be \" +\r\n\t           \"a \\\"function\\\" or \\\"object\\\"\");\r\n\t       }\r\n\t       if (typeof factory === \"object\" && !(\"create\" in factory)) {\r\n\t         throw new DependencyResolverException(\"Factory's instance passed to the method \\\"setFactory\\\" has to have \" +\r\n\t           \"a method \\\"create\\\"\");\r\n\t       }\r\n\t       if (!this.__registration.type) {\r\n\t         throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name);\r\n\t       }\r\n\t       this.__registration.factory = factory;\r\n\t       this.__withConstructor = false;\r\n\t       this.__withProperties = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   create: {\r\n\t     value: function () {\r\n\t       return new DependencyResolver(this);\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   inject: {\r\n\t     value: function (func) {\r\n\t       if (!func) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"func\\\" is not passed to method \\\"inject\\\"\");\r\n\t       }\r\n\t       var i,\r\n\t           parameters = [],\r\n\t           context = { resolving: [] };\r\n\t       if (func instanceof Array) {\r\n\t         if (func.length === 0) {\r\n\t           throw new DependencyResolverException(\"The array passed to the method \\\"inject\\\" can't be empty\");\r\n\t         }\r\n\t         for (i = 0; i < func.length - 1; i++) {\r\n\t           parameters.push(func[i]);\r\n\t         }\r\n\t         func = func[func.length - 1];\r\n\t         if (typeof func !== \"function\") {\r\n\t           throw new DependencyResolverException(\"The last item of the array passed to the method \\\"inject\\\" has \" +\r\n\t             \"to be a \\\"function\\\"\");\r\n\t         }\r\n\t         for (i = 0; i < parameters.length; i++) {\r\n\t           if (typeof parameters[i] === \"string\" && this.contains(parameters[i])) {\r\n\t             parameters[i] = this.__resolve(parameters[i], context);\r\n\t           }\r\n\t         }\r\n\t         func.apply(null, parameters);\r\n\t       } else {\r\n\t         var registration = null;\r\n\t         if (arguments.length === 2 && typeof arguments[1] === \"string\") {\r\n\t           var name = arguments[1];\r\n\t           if (!this.contains(name)) {\r\n\t             throw new DependencyResolverException(\"Type with name \\\"\" + name + \"\\\" is not registered\");\r\n\t           }\r\n\t           registration = this.getRegistration(name);\r\n\t         }\r\n\t         var dependencyName;\r\n\t         if (typeof func === \"function\") {\r\n\t           if (registration) {\r\n\t             parameters = this.__getConstructorParameters(registration, context);\r\n\t           } else {\r\n\t             var args = this.__getFunctionArguments(func);\r\n\t             for (i = 0; i < args.length; i++) {\r\n\t               dependencyName = this.__resolveDependencyName(args[i]);\r\n\t               if (this.contains(dependencyName)) {\r\n\t                 parameters.push(this.__resolve(dependencyName, context));\r\n\t               } else {\r\n\t                 parameters.push(null);\r\n\t               }\r\n\t             }\r\n\t           }\r\n\t           func.apply(null, parameters);\r\n\t         } else if (typeof func === \"object\") {\r\n\t           if (registration) {\r\n\t             this.__setProperties(func, registration, context);\r\n\t             this.__invokeFunctions(func, registration, context);\r\n\t           } else {\r\n\t             for (var propertyName in func) {//eslint-disable-line guard-for-in\r\n\t               dependencyName = this.__resolveDependencyName(propertyName);\r\n\t               if (this.contains(dependencyName)) {\r\n\t                 parameters.push({\r\n\t                   name: propertyName,\r\n\t                   value: this.__resolve(dependencyName, context)\r\n\t                 });\r\n\t               }\r\n\t             }\r\n\t             if (parameters.length > 0) {\r\n\t               for (i = 0; i < parameters.length; i++) {\r\n\t                 func[parameters[i].name] = parameters[i].value;\r\n\t               }\r\n\t             }\r\n\t           }\r\n\t         } else {\r\n\t           throw new DependencyResolverException(\"Invalid parameter has been passed to the method \\\"inject\\\"\");\r\n\t         }\r\n\t       }\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   contains: {\r\n\t     value: function (name) {\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"contains\\\"\");\r\n\t       }\r\n\t       if (typeof name !== \"string\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the  has to be a \\\"string\\\"\");\r\n\t       }\r\n\t       var has = false;\r\n\t       if (this.__container) {\r\n\t         if (name in this.__container) {\r\n\t           has = true;\r\n\t         }\r\n\t       }\r\n\t       if (!has && this.__parent) {\r\n\t         if (!(\"contains\" in this.__parent)) {\r\n\t           throw new DependencyResolverException(\"Dependency resolver's parent doesn't have a method \\\"contains\\\"\");\r\n\t         }\r\n\t         has = this.__parent.contains(name);\r\n\t       }\r\n\t       return has;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   resolve: {\r\n\t     value: function (name) {\r\n\t       return this.__resolve(name, { \r\n\t         resolving: [] \r\n\t       });\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   getDefaultFactory: {\r\n\t     value: function () {\r\n\t       var factory = null;\r\n\t       if (this.__defaultFactory) {\r\n\t         factory = this.__defaultFactory;\r\n\t       } else if (this.__parent) {\r\n\t         if (!(\"getDefaultFactory\" in this.__parent)) {\r\n\t           throw new DependencyResolverException(\"Dependency resolver's parent doesn't have a \" +\r\n\t             \"method \\\"getDefaultFactory\\\"\");\r\n\t         }\r\n\t         factory = this.__parent.getDefaultFactory();\r\n\t       } else {\r\n\t         factory = new InstanceFactory();\r\n\t       }\r\n\t       return factory;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   setDefaultFactory: {\r\n\t     value: function (factory) {\r\n\t       if (!factory) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"factory\\\" is not passed to the method \" +\r\n\t           \"\\\"setDefaultFactory\\\"\");\r\n\t       }\r\n\t       if (typeof factory !== \"function\" && typeof factory !== \"object\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"factory\\\" passed to the method \\\"setDefaultFactory\\\" has \" +\r\n\t           \" to be a \\\"function\\\" or \\\"object\\\"\");\r\n\t       }\r\n\t       if (typeof factory === \"object\" && !(\"create\" in factory)) {\r\n\t         throw new DependencyResolverException(\"Factory's instance passed to the method \\\"setDefaultFactory\\\" has \" +\r\n\t           \"to have a method \\\"create\\\"\");\r\n\t       }\r\n\t       this.__defaultFactory = factory;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   getNameTransformer: {\r\n\t     value: function () {\r\n\t       var transformer = null;\r\n\t       if (this.__nameTransformer) {\r\n\t         transformer = this.__nameTransformer;\r\n\t       } else if (this.__parent) {\r\n\t         if (!(\"getNameTransformer\" in this.__parent)) {\r\n\t           throw new DependencyResolverException(\"Dependency resolver's parent doesn't have a \" +\r\n\t             \"method \\\"getNameTransformer\\\"\");\r\n\t         }\r\n\t         transformer = this.__parent.getNameTransformer();\r\n\t       } else {\r\n\t         transformer = new NameTransformer();\r\n\t       }\r\n\t       return transformer;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   setNameTransformer: {\r\n\t     value: function (transformer) {\r\n\t       if (!transformer) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"transformer\\\" is not passed to the method \" +\r\n\t           \"\\\"setNameTransformer\\\"\");\r\n\t       }\r\n\t       if (typeof transformer !== \"function\" && typeof transformer !== \"object\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"transformer\\\" passed to the method \\\"setNameTransformer\\\" \" +\r\n\t           \"has to be a \\\"function\\\" or \\\"object\\\"\");\r\n\t       }\r\n\t       if (typeof transformer === \"object\" && !(\"transform\" in transformer)) {\r\n\t         throw new DependencyResolverException(\"Trabsformers's instance passed to the method \\\"setNameTransformer\\\" \" +\r\n\t           \"has to have a method \\\"transform\\\"\");\r\n\t       }\r\n\t       this.__nameTransformer = transformer;\r\n\t       return this;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   getRegistration: {\r\n\t     value: function (name) {\r\n\t       var registration = null;\r\n\t       if (this.__container && name in this.__container) {\r\n\t         registration = this.__container[name];\r\n\t       } else if (this.__parent) {\r\n\t         if (!(\"getRegistration\" in this.__parent)) {\r\n\t           throw new DependencyResolverException(\"Dependency resolver\\\"s parent doesn't have a \" +\r\n\t             \"method \\\"getRegistration\\\"\");\r\n\t         }\r\n\t         registration = this.__parent.getRegistration(name);\r\n\t       }\r\n\t       return registration;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   dispose: {\r\n\t     value: function () {\r\n\t       var registration = null, \r\n\t           i = 0;\r\n\t       if (this.__container) {\r\n\t         for (var name in this.__container) {\r\n\t           if (!(this.__container[name] instanceof Array)) {\r\n\t             registration = this.__container[name];\r\n\t             if (registration.instance && (\"dispose\" in registration.instance)) {\r\n\t               registration.instance.dispose();\r\n\t             }\r\n\t             registration.instance = null;\r\n\t             registration.factory = null;\r\n\t           } else {\r\n\t             var registrations = this.__container[name];\r\n\t             for (i = 0; i < registrations.length; i++) {\r\n\t               registration = registrations[i];\r\n\t               if (registration.instance && (\"dispose\" in registration.instance)) {\r\n\t                 registration.instance.dispose();\r\n\t               }\r\n\t               registration.instance = null;\r\n\t               registration.factory = null;\r\n\t             }\r\n\t           }\r\n\t         }\r\n\t       }\r\n\t       this.__parent = null;\r\n\t       this.__defaultFactory = null;\r\n\t       this.__nameTransformer = null;\r\n\t       this.__autowired = false;\r\n\t       this.__container = null;\r\n\t       this.__registration = null;\r\n\t       this.__withProperties = false;\r\n\t       this.__withConstructor = false;\r\n\t       this.__parameter = null;\r\n\t       this.__property = null;\r\n\t       this.__function = null;\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   toString: {\r\n\t     value: function () {\r\n\t       return \"[object DependencyResolver]\";\r\n\t     },\r\n\t     enumerable: true\r\n\t   },\r\n\t \r\n\t   __getFunctionArguments: {\r\n\t     value: function (func) {\r\n\t       if (func && typeof func === \"function\" && \"toString\" in func) {\r\n\t         var str = null;\r\n\t         var result = _.function_toString.call(func)\r\n\t           .match(/^[\\s\\(]*function[^(]*\\(([^)]*)\\)/);\r\n\t         if (result && result.length > 1) {\r\n\t           str = result[1]\r\n\t             .replace(/\\/\\/.*?[\\r\\n]|\\/\\*(?:.|[\\r\\n])*?\\*\\//g, \"\")\r\n\t             .replace(/\\s+/g, \"\");\r\n\t         }\r\n\t         if (str) {\r\n\t           return str.split(\",\");\r\n\t         }\r\n\t       }\r\n\t       return [];\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __resolve: {\r\n\t     value: function (name, context) {\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"resolve\\\"\");\r\n\t       }\r\n\t       if (typeof name !== \"string\") {\r\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"resolve\\\" has to be \" +\r\n\t           \"a \\\"string\\\"\");\r\n\t       }\r\n\t       if (debug && console && \"log\" in console) {\r\n\t         var message = \"-> \\\"\" + name + \"\\\"\";\r\n\t         for (var j = 0; j < context.resolving.length; j++) {\r\n\t           message = \"  \" + message;\r\n\t         }\r\n\t         console.log(message);\r\n\t       }\r\n\t       if (!this.contains(name)) {\r\n\t         throw new DependencyResolverException(\"Type or instance with name \\\"\" + name + \"\\\" is not registered\");\r\n\t       }\r\n\t       var index = _.indexOf(context.resolving, name);\r\n\t       if (index !== -1) {\r\n\t         throw new DependencyResolverException(\"Can not resolve circular dependency \\\"\" + name + \"\\\"\");\r\n\t       }\r\n\t       context.resolving.push(name);\r\n\t       var instance = null,\r\n\t           registration = this.getRegistration(name);\r\n\t       if (!(registration instanceof Array)) {\r\n\t         instance = this.__resolveInstance(registration, context);\r\n\t       } else {\r\n\t         instance = [];\r\n\t         for (var i = 0; i < registration.length; i++) {\r\n\t           instance.push(this.__resolveInstance(registration[i], context));\r\n\t         }\r\n\t       }\r\n\t       index = _.indexOf(context.resolving, name);\r\n\t       if (index > -1) {\r\n\t         context.resolving.splice(index, 1);\r\n\t       }\r\n\t       return instance;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __resolveInstance: {\r\n\t     value: function (registration, context) {\r\n\t       var instance = null;\r\n\t       if (registration.instance !== null && registration.instance !== undefined) {\r\n\t         instance = registration.instance;\r\n\t       } else {\r\n\t         instance = this.__createInstance(registration, context);\r\n\t         this.__setProperties(instance, registration, context);\r\n\t         this.__invokeFunctions(instance, registration, context);\r\n\t         if (instance && registration.singleton) {\r\n\t           registration.instance = instance;\r\n\t         }\r\n\t         if (!instance) {\r\n\t           throw new DependencyResolverException(\"Failed to resolve instance by name \\\"\" + registration.name + \"\\\"\");\r\n\t         }\r\n\t       }\r\n\t       return instance;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __resolveDependencyName: {\r\n\t     value: function (name) {\r\n\t       var transform = this.getNameTransformer();\r\n\t       if (typeof transform === \"function\") {\r\n\t         name = transform(name);\r\n\t       } else {\r\n\t         name = transform.transform(name);\r\n\t       }\r\n\t       if (!name) {\r\n\t         throw new DependencyResolverException(\"Failed to resolve dependency name\");\r\n\t       }\r\n\t       return name;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __createInstance: {\r\n\t     value: function (registration, context) {\r\n\t       var i,//eslint-disable-line no-unused-vars\r\n\t           instance;\r\n\t       var parameters = this.__getConstructorParameters(registration, context);\r\n\t       var options = new InstanceFactoryOptions({\r\n\t         name: registration.name,\r\n\t         type: registration.type,\r\n\t         parameters: parameters\r\n\t       });\r\n\t       var factory = null;\r\n\t       if (registration.factory) {\r\n\t         factory = registration.factory;\r\n\t       } else {\r\n\t         factory = this.getDefaultFactory();\r\n\t       }\r\n\t       if (factory) {\r\n\t         if (typeof factory === \"function\") {\r\n\t           instance = factory.call(null, options);\r\n\t         } else {\r\n\t           instance = factory.create(options);\r\n\t         }\r\n\t       } else {\r\n\t         throw new DependencyResolverException(\"Default factory is not defined\");\r\n\t       }\r\n\t       return instance;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __getConstructorParameters: {\r\n\t     value: function (registration, context) {\r\n\t       var parameters = [];\r\n\t       if (registration && registration.dependencies) {\r\n\t         var i,\r\n\t             parameter,\r\n\t             value,\r\n\t             args,\r\n\t             index;\r\n\t         if (this.__autowired) {\r\n\t           args = this.__getFunctionArguments(registration.type);\r\n\t           var dependencyName;\r\n\t           for (i = 0; i < args.length; i++) {\r\n\t             dependencyName = this.__resolveDependencyName(args[i]);\r\n\t             if (this.contains(dependencyName)) {\r\n\t               parameters.push(this.__resolve(dependencyName, context));\r\n\t             } else {\r\n\t               parameters.push(null);\r\n\t             }\r\n\t           }\r\n\t         }\r\n\t         for (i = 0; i < registration.dependencies.parameters.length; i++) {\r\n\t           parameter = registration.dependencies.parameters[i];\r\n\t           if (parameter.value !== undefined) {\r\n\t             value = parameter.value;\r\n\t           } else if (parameter.reference !== undefined) {\r\n\t             value = this.__resolve(parameter.reference, context);\r\n\t           } else {\r\n\t             value = null;\r\n\t           }\r\n\t           if (parameter.index !== undefined && parameter.index !== null) {\r\n\t             parameters[parameter.index] = value;\r\n\t           } else if (parameter.name) {\r\n\t             if (!args) {\r\n\t               args = this.__getFunctionArguments(registration.type);\r\n\t             }\r\n\t             index = _.indexOf(args, parameter.name);\r\n\t             if (index === -1) {\r\n\t               throw new DependencyResolverException(\"Constructor in registration \\\"\" + registration.name +\r\n\t                 \"\\\" doesn't have defined parameter \\\"\" + parameter.name + \"\\\"\");\r\n\t             }\r\n\t             parameters[index] = value;\r\n\t           } else {\r\n\t             parameters.push(value);\r\n\t           }\r\n\t         }\r\n\t       }\r\n\t       return parameters;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __hasProperty: {\r\n\t     value: function (registration, name) {\r\n\t       var has = false;\r\n\t       if (registration.dependencies) {\r\n\t         var property;\r\n\t         for (var i = 0; i < registration.dependencies.properties.length; i++) {\r\n\t           property = registration.dependencies.properties[i];\r\n\t           if (property.name === name) {\r\n\t             has = true;\r\n\t             break;\r\n\t           }\r\n\t         }\r\n\t       }\r\n\t       return has;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __findParameter: {\r\n\t     value: function (name, parameters, registration) {\r\n\t       var parameter = null;\r\n\t       if (name !== null && name !== undefined && registration !== null) {\r\n\t         if (typeof name === \"number\") {\r\n\t           index = name;\r\n\t           name = undefined;\r\n\t           if (index < 0) {\r\n\t             throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"param\\\" is out of \" +\r\n\t               \"range for registration \\\"\" + registration.name + \"\\\"\");\r\n\t           }\r\n\t           if (index < parameters.length) {\r\n\t             parameter = parameters[index];\r\n\t           }\r\n\t         } else if (typeof name === \"string\") {\r\n\t           for (var i = 0; i < parameters.length; i++) {\r\n\t             if (parameters[i].name === name) {\r\n\t               parameter = parameters[i];\r\n\t               break;\r\n\t             }\r\n\t           }\r\n\t         } else {\r\n\t           throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"param\\\" has to \" +\r\n\t             \"be a \\\"number\\\" or a \\\"string\\\" for registration \\\"\" + registration.name + \"\\\"\");\r\n\t         }\r\n\t       }\r\n\t       return parameter;\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __setProperties: {\r\n\t     value: function (instance, registration, context) {\r\n\t       if (registration.dependencies) {\r\n\t         if (this.__autowired) {\r\n\t           for (var propertyName in instance) {//eslint-disable-line guard-for-in\r\n\t             var dependencyName = this.__resolveDependencyName(propertyName);\r\n\t             if (!this.__hasProperty(registration, propertyName) && this.contains(dependencyName)) {\r\n\t               instance[propertyName] = this.__resolve(dependencyName, context);\r\n\t             }\r\n\t           }\r\n\t         }\r\n\t         for (var i = 0; i < registration.dependencies.properties.length; i++) {\r\n\t           var property = registration.dependencies.properties[i];\r\n\t           if (!(property.name in instance)) {\r\n\t             throw new DependencyResolverException(\"Resolved object \\\"\" + registration.name +\r\n\t               \"\\\" doesn't have property \\\"\" + property.name + \"\\\"\");\r\n\t           }\r\n\t           if (property.value !== undefined) {\r\n\t             instance[property.name] = property.value;\r\n\t           } else if (property.reference !== undefined) {\r\n\t             instance[property.name] = this.__resolve(property.reference, context);\r\n\t           }\r\n\t         }\r\n\t       }\r\n\t     }\r\n\t   },\r\n\t \r\n\t   __invokeFunctions: {\r\n\t     value: function (instance, registration, context) {\r\n\t       if (registration.dependencies) {\r\n\t         var i, \r\n\t             j, \r\n\t             parameter, \r\n\t             value;\r\n\t         for (i = 0; i < registration.dependencies.functions.length; i++) {\r\n\t           var func = registration.dependencies.functions[i];\r\n\t           if (!(func.name in instance)) {\r\n\t             throw new DependencyResolverException(\"Resolved object \\\"\" + registration.name +\r\n\t               \"\\\" doesn't have function \\\"\" + func.name + \"\\\"\");\r\n\t           }\r\n\t           var parameters = [];\r\n\t           for (j = 0; j < func.parameters.length; j++) {\r\n\t             parameter = func.parameters[j];\r\n\t             if (parameter.value !== undefined) {\r\n\t               value = parameter.value;\r\n\t             } else if (parameter.reference !== undefined) {\r\n\t               value = this.__resolve(parameter.reference, context);\r\n\t             } else {\r\n\t               value = null;\r\n\t             }\r\n\t             if (parameter.index !== undefined && parameter.index !== null) {\r\n\t               parameters[parameter.index] = value;\r\n\t             } else if (parameter.name) {\r\n\t               if (!args) {\r\n\t                 args = this.__getFunctionArguments(instance[func.name]);//eslint-disable-line\r\n\t               }\r\n\t               index = _.indexOf(args, parameter.name);\r\n\t               if (index === -1) {\r\n\t                 throw new DependencyResolverException(\"Function doesn't have defined parameter \\\"\" +\r\n\t                   parameter.name + \"\\\"\");\r\n\t               }\r\n\t               parameters[index] = value;\r\n\t             } else {\r\n\t               parameters.push(value);\r\n\t             }\r\n\t           }\r\n\t           instance[func.name].apply(instance, parameters);\r\n\t         }\r\n\t       }\r\n\t     }\r\n\t   }\r\n\t \r\n\t });\r\n\t \r\n\t Object.seal(DependencyResolver);\r\n\t Object.seal(DependencyResolver.prototype);\r\n\t \r\n\t exports.DependencyResolver = DependencyResolver;\r\n\r\n\t /* global DependencyResolver*/\r\n\t var defaultDependencyResolver = null,\r\n\t     debug = false;\r\n\t \r\n\t Object.defineProperty(exports, \"getDefaultDependencyResolver\", {\r\n\t   value: function () {\r\n\t     if (!defaultDependencyResolver) {\r\n\t       defaultDependencyResolver = new DependencyResolver();\r\n\t     }\r\n\t     return defaultDependencyResolver;\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"setDefaultDependencyResolver\", {\r\n\t   value: function (value) {\r\n\t     defaultDependencyResolver = value;\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"isAutowired\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .isAutowired();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"autowired\", {\r\n\t   value: function (value) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .autowired(value);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"register\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .register(name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"as\", {\r\n\t   value: function (type) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .as(type);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"instance\", {\r\n\t   value: function (instance) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .instance(instance);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"asSingleton\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .asSingleton();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"withConstructor\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .withConstructor();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"param\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .param(name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"withProperties\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .withProperties();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"prop\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .prop(name);\r\n\t   }\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"func\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .func(name);\r\n\t   }\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"val\", {\r\n\t   value: function (instance) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .val(instance);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"ref\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .ref(name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"setFactory\", {\r\n\t   value: function (factory) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .setFactory(factory);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"create\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .create();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"inject\", {\r\n\t   value: function (func, name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .inject(func, name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"contains\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .contains(name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"resolve\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .resolve(name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"getDefaultFactory\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .getDefaultFactory();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"setDefaultFactory\", {\r\n\t   value: function (factory) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .setDefaultFactory(factory);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"getNameTransformer\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .getNameTransformer();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"setNameTransformer\", {\r\n\t   value: function (transformer) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .setNameTransformer(transformer);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"getRegistration\", {\r\n\t   value: function (name) {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .getRegistration(name);\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"debug\", {\r\n\t   value:debug,\r\n\t   enumerable: true\r\n\t });\r\n\t \r\n\t Object.defineProperty(exports, \"dispose\", {\r\n\t   value: function () {\r\n\t     return exports\r\n\t       .getDefaultDependencyResolver()\r\n\t       .dispose();\r\n\t   },\r\n\t   enumerable: true\r\n\t });\r\n\r\n\t var\r\n\t \t// Map over the di in case of overwrite\r\n\t \t_di = window.di;\r\n\t \r\n\t exports.noConflict = function () {\r\n\t     if (window.di === exports) {\r\n\t         window.di = _di;\r\n\t     }\r\n\t \r\n\t     return exports;\r\n\t };\r\n\t \r\n\r\n\t} (exports, shim.object, shim._));\r\n\r\n window.di = exports;\r\n\r\n} ());\r\n\r\n"],"file":"di4es.js"}
{"version":3,"names":[],"mappings":"","sources":["di4es.js"],"sourcesContent":["/* di4js (ver. 2.1.0). https://github.com/flamencist/di4es */\n\n(function () {\n\n  \"use strict\";\n\n  var exports = {};\n\n  if (!(\"version\" in exports)) {\n    exports.version = \"2.1.0\";\n  }\n\n  //http://stackoverflow.com/questions/6598945/detect-if-function-is-native-to-browser\nvar isFuncNative = function isFuncNative(f) {\n    return !!f && (typeof f).toLowerCase() === \"function\" &&\n        //jshint maxlen=300\n        (/^\\s*function\\s*(\\b[a-z$_][a-z0-9$_]*\\b)*\\s*\\((|([a-z$_][a-z0-9$_]*)(\\s*,[a-z$_][a-z0-9$_]*)*)\\)\\s*\\{\\s*\\[native code\\]\\s*}\\s*$/i.test(String(f))\n        || f === Function.prototype);\n};\n\nvar shim = {\n    object: {},\n    _: {}\n};\n\n//noinspection Eslint\nshim._.function_toString = Function.prototype.toString;\nvar call = Function.call;\n\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n\nvar prototypeOfObject = Object.prototype;\nshim.object.prototype = prototypeOfObject;\nvar owns = uncurryThis(prototypeOfObject.hasOwnProperty);\nvar isEnumerable = uncurryThis(prototypeOfObject.propertyIsEnumerable);\nvar toStr = uncurryThis(prototypeOfObject.toString);\n\n// If JS engine supports accessors creating shortcuts.\nvar defineGetter;\nvar defineSetter;\nvar lookupGetter;\nvar lookupSetter;\nvar supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\");\nif (supportsAccessors) {\n    /* eslint-disable no-underscore-dangle */\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n    /* eslint-enable no-underscore-dangle */\n}\n\n// Having a toString local variable name breaks in Opera so use to_string.\nvar to_string = prototypeOfObject.toString;\n\nvar isFunction = function (val) {\n    return to_string.call(val) === \"[object Function]\";\n};\nvar isArray = function isArray(obj) {\n    return to_string.call(obj) === \"[object Array]\";\n};\nvar isString = function isString(obj) {\n    return to_string.call(obj) === \"[object String]\";\n};\nvar isArguments = function isArguments(value) {\n    var str = to_string.call(value);\n    var isArgs = str === \"[object Arguments]\";\n    if (!isArgs) {\n        isArgs = !isArray(value) &&\n            value !== null &&\n            typeof value === \"object\" &&\n            typeof value.length === \"number\" &&\n            value.length >= 0 &&\n            isFunction(value.callee);\n    }\n    return isArgs;\n};\n\n\n// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\nvar hasDontEnumBug = !({\"toString\": null}).propertyIsEnumerable(\"toString\"),\n    hasProtoEnumBug = function () {\n    }.propertyIsEnumerable(\"prototype\"),\n    hasStringEnumBug = !owns(\"x\", \"0\"),\n    dontEnums = [\n        \"toString\",\n        \"toLocaleString\",\n        \"valueOf\",\n        \"hasOwnProperty\",\n        \"isPrototypeOf\",\n        \"propertyIsEnumerable\",\n        \"constructor\"\n    ],\n    dontEnumsLength = dontEnums.length;\n\nvar toObject = function (o) {\n    /*jshint eqnull: true */\n    //noinspection Eslint\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can\\\"t convert \" + o + \" to object\");\n    }\n    return Object(o);\n};\n\nshim._.indexOf = Array.prototype.indexOf && isFuncNative(Array.prototype.indexOf) ?\n    function (arr, sought) {\n        return arr.indexOf(sought);\n    } :\n    function indexOf(arr, sought /*, fromIndex */) {\n        var length = arr.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in arr && arr[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\nvar array_forEach = function forEach(arr, fun) {\n    var thisp = arguments[2],\n        i = -1,\n        length = arr.length >>> 0;\n\n    // If no callback function or if callback is not a callable function\n    if (!isFunction(fun)) {\n        throw new TypeError(); // TODO message\n    }\n\n    while (++i < length) {\n        if (i in arr) {\n            // Invoke the callback function with call, passing arguments:\n            // context, property value, property key, thisArg object\n            // context\n            fun.call(thisp, arr[i], i, arr);\n        }\n    }\n};\n\nshim.object.keys = Object.keys && isFuncNative(Object.keys) ? Object.keys : function keys(object) {\n    var isFn = isFunction(object),\n        isArgs = isArguments(object),\n        isObject = object !== null && typeof object === \"object\",\n        isStr = isObject && isString(object);\n\n    if (!isObject && !isFn && !isArgs) {\n        throw new TypeError(\"Object.keys called on a non-object\");\n    }\n\n    var theKeys = [];\n    var skipProto = hasProtoEnumBug && isFn;\n    if ((isStr && hasStringEnumBug) || isArgs) {\n        for (var i = 0; i < object.length; ++i) {\n            theKeys.push(String(i));\n        }\n    }\n\n    if (!isArgs) {\n        for (var name in object) {\n            if (!(skipProto && name === \"prototype\") && owns(object, name)) {\n                theKeys.push(String(name));\n            }\n        }\n    }\n\n    if (hasDontEnumBug) {\n        var ctor = object.constructor,\n            skipConstructor = ctor && ctor.prototype === object;\n        for (var j = 0; j < dontEnumsLength; j++) {\n            var dontEnum = dontEnums[j];\n            if (!(skipConstructor && dontEnum === \"constructor\") && owns(object, dontEnum)) {\n                theKeys.push(dontEnum);\n            }\n        }\n    }\n    return theKeys;\n};\n\nshim.object.getPrototypeOf = Object.getPrototypeOf && isFuncNative(Object.getPrototypeOf) ? Object.getPrototypeOf :\n    function getPrototypeOf(object) {\n        /* jshint ignore:start */\n        var proto = object.__proto__;\n        /* jshint ignore:end */\n        if (proto || proto === null) {\n            return proto;\n        } else if (toStr(object.constructor) === \"[object Function]\") {\n            return object.constructor.prototype;\n        } else if (object instanceof Object) {\n            return prototypeOfObject;\n        } else {\n            // Correctly return null for Objects created with `Object.create(null)`\n            // (shammed or native) or `{ __proto__: null}`.  Also returns null for\n            // cross-realm objects on browsers that lack `__proto__` support (like\n            // IE <11), but that\"s the best we can do.\n            return null;\n        }\n    };\n\nvar doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {\n    try {\n        object.sentinel = 0;\n        return Object.getOwnPropertyDescriptor(object, \"sentinel\").value === 0;\n    } catch (exception) {\n        return false;\n    }\n};\n\n// check whether getOwnPropertyDescriptor works if it\"s given. Otherwise, shim partially.\nvar getOwnPropertyDescriptorFallback;\nif (Object.defineProperty) {\n    var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});\n    var getOwnPropertyDescriptorWorksOnDom = typeof document === \"undefined\" ||\n        doesGetOwnPropertyDescriptorWork(document.createElement(\"div\"));\n    if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {\n        getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;\n    }\n}\n\nvar ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a non-object: \";\n\n/* eslint-disable no-proto */\nshim.object.getOwnPropertyDescriptor =\n    (Object.getOwnPropertyDescriptor && getOwnPropertyDescriptorFallback) && isFuncNative(Object.getOwnPropertyDescriptor) ?\n        Object.getOwnPropertyDescriptor :\n        function getOwnPropertyDescriptor(object, property) {\n            if ((typeof object !== \"object\" && typeof object !== \"function\") || object === null) {\n                throw new TypeError(ERR_NON_OBJECT + object);\n            }\n\n            // make a valiant attempt to use the real getOwnPropertyDescriptor\n            // for I8\"s DOM elements.\n            if (getOwnPropertyDescriptorFallback) {\n                try {\n                    return getOwnPropertyDescriptorFallback.call(Object, object, property);\n                } catch (exception) {\n                    // try the shim if the real one doesn't work\n                }\n            }\n\n            var descriptor;\n\n            // If object does not owns property return undefined immediately.\n            if (!owns(object, property)) {\n                return descriptor;\n            }\n\n            // If object has a property then it\"s for sure `configurable`, and\n            // probably `enumerable`. Detect enumerability though.\n            descriptor = {\n                enumerable: isEnumerable(object, property),\n                configurable: true\n            };\n\n            // If JS engine supports accessor properties then property may be a\n            // getter or setter.\n            if (supportsAccessors) {\n                // Unfortunately `__lookupGetter__` will return a getter even\n                // if object has own non getter property along with a same named\n                // inherited getter. To avoid misbehavior we temporary remove\n                // `__proto__` so that `__lookupGetter__` will return getter only\n                // if it\"s owned by an object.\n                /* jshint ignore:start */\n                var prototype = object.__proto__;\n                /* jshint ignore:end */\n\n\n                var notPrototypeOfObject = object !== prototypeOfObject;\n                // avoid recursion problem, breaking in Opera Mini when\n                // Object.getOwnPropertyDescriptor(Object.prototype, \"toString\")\n                // or any other Object.prototype accessor\n                if (notPrototypeOfObject) {\n                    /* jshint ignore:start */\n                    object.__proto__ = prototypeOfObject;\n                    /* jshint ignore:end */\n                }\n\n                var getter = lookupGetter(object, property);\n                var setter = lookupSetter(object, property);\n\n                if (notPrototypeOfObject) {\n                    // Once we have getter and setter we can put values back.\n                    object.__proto__ = prototype; //jshint ignore:line\n                }\n\n                if (getter || setter) {\n                    if (getter) {\n                        descriptor.get = getter;\n                    }\n                    if (setter) {\n                        descriptor.set = setter;\n                    }\n                    // If it was accessor property we\"re done and return here\n                    // in order to avoid adding `value` to the descriptor.\n                    return descriptor;\n                }\n            }\n\n            // If we got this far we know that object has an own property that is\n            // not an accessor so we set it as a value and return descriptor.\n            descriptor.value = object[property];\n            descriptor.writable = true;\n            return descriptor;\n        };\n/* eslint-enable no-proto */\n\nshim.object.getOwnPropertyNames = Object.getOwnPropertyNames && isFuncNative(Object.getOwnPropertyNames) ?\n    Object.getOwnPropertyNames :\n    function getOwnPropertyNames(object) {\n        return shim.object.keys(object);\n    };\n\nif (!Object.create || !isFuncNative(Object.create)) {\n\n    // Contributed by Brandon Benvie, October, 2012\n    var createEmpty;\n    var supportsProto = !({__proto__: null} instanceof Object);//jshint ignore:line\n    // the following produces false positives\n    // in Opera Mini => not a reliable check\n    // Object.prototype.__proto__ === null\n\n    // Check for document.domain and active x support\n    // No need to use active x approach when document.domain is not set\n    // see https://github.com/es-shims/es5-shim/issues/150\n    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n    /* global ActiveXObject */\n    var shouldUseActiveX = function shouldUseActiveX() {\n        // return early if document.domain not set\n        if (!document.domain) {\n            return false;\n        }\n\n        try {\n            return !!new ActiveXObject(\"htmlfile\");\n        } catch (exception) {\n            return false;\n        }\n    };\n\n    // This supports IE8 when document.domain is used\n    // see https://github.com/es-shims/es5-shim/issues/150\n    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n    var getEmptyViaActiveX = function getEmptyViaActiveX() {\n        var empty;\n        var xDoc;\n\n        xDoc = new ActiveXObject(\"htmlfile\");\n\n        xDoc.write(\"<script><\\/script>\");\n        xDoc.close();\n\n        empty = xDoc.parentWindow.Object.prototype;\n        xDoc = null;\n\n        return empty;\n    };\n\n    // The original implementation using an iframe\n    // before the activex approach was added\n    // see https://github.com/es-shims/es5-shim/issues/150\n    var getEmptyViaIFrame = function getEmptyViaIFrame() {\n        var iframe = document.createElement(\"iframe\");\n        var parent = document.body || document.documentElement;\n        var empty;\n\n        iframe.style.display = \"none\";\n        parent.appendChild(iframe);\n        /* jshint ignore:start */\n        iframe.src = \"javascript:\";\n        /* jshint ignore:end */\n\n        empty = iframe.contentWindow.Object.prototype;\n        parent.removeChild(iframe);\n        iframe = null;\n\n        return empty;\n    };\n\n    /* global document */\n    if (supportsProto || typeof document === \"undefined\") {\n        createEmpty = function () {\n            return {__proto__: null}; //jshint ignore:line\n        };\n    } else {\n        // In old IE __proto__ can\"t be used to manually set `null`, nor does\n        // any other method exist to make an object that inherits from nothing,\n        // aside from Object.prototype itself. Instead, create a new global\n        // object and *steal* its Object.prototype and strip it bare. This is\n        // used as the prototype to create nullary objects.\n        createEmpty = function () {\n            // Determine which approach to use\n            // see https://github.com/es-shims/es5-shim/issues/150\n            var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();\n\n            delete empty.constructor;\n            delete empty.hasOwnProperty;\n            delete empty.propertyIsEnumerable;\n            delete empty.isPrototypeOf;\n            delete empty.toLocaleString;\n            delete empty.toString;\n            delete empty.valueOf;\n\n            var Empty = function Empty() {\n            };\n            Empty.prototype = empty;\n            // short-circuit future calls\n            createEmpty = function () {\n                return new Empty();\n            };\n            return new Empty();\n        };\n    }\n\n    shim.object.create = function create(prototype, properties) {\n\n        var object;\n        var Type = function Type() {\n        }; // An empty constructor.\n\n        if (prototype === null) {\n            object = createEmpty();\n        } else {\n            if (typeof prototype !== \"object\" && typeof prototype !== \"function\") {\n                // In the native implementation `parent` can be `null`\n                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)\n                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`\n                // like they are in modern browsers. Using `Object.create` on DOM elements\n                // is...err...probably inappropriate, but the native version allows for it.\n                throw new TypeError(\"Object prototype may only be an Object or null\"); // same msg as Chrome\n            }\n            Type.prototype = prototype;\n            object = new Type();\n            // IE has no built-in implementation of `Object.getPrototypeOf`\n            // neither `__proto__`, but this manually setting `__proto__` will\n            // guarantee that `Object.getPrototypeOf` will work as expected with\n            // objects created using `Object.create`\n            /* eslint-disable no-proto */\n            object.__proto__ = prototype;//jshint ignore:line\n            /* eslint-enable no-proto */\n        }\n\n        if (properties !== void 0) {\n            shim.object.defineProperties(object, properties);\n        }\n\n        return object;\n    };\n} else {\n    shim.object.create = Object.create;\n}\n\nvar doesDefinePropertyWork = function doesDefinePropertyWork(object) {\n    try {\n        Object.defineProperty(object, \"sentinel\", {});\n        return \"sentinel\" in object;\n    } catch (exception) {\n        return false;\n    }\n};\n\n// check whether defineProperty works if it\"s given. Otherwise,\n// shim partially.\nvar definePropertyFallback;\nvar definePropertiesFallback;\nif (Object.defineProperty && isFuncNative(Object.defineProperty)) {\n    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n    var definePropertyWorksOnDom = typeof document === \"undefined\" ||\n        doesDefinePropertyWork(document.createElement(\"div\"));\n    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n        definePropertyFallback = Object.defineProperty;\n        definePropertiesFallback = Object.defineProperties;\n    }\n}\n\nif (!Object.defineProperty || definePropertyFallback || !isFuncNative(Object.defineProperty)) {\n    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\n    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \";\n    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined on this javascript engine\";\n\n    shim.object.defineProperty = function defineProperty(object, property, descriptor) {\n        if ((typeof object !== \"object\" && typeof object !== \"function\") || object === null) {\n            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n        }\n        if ((typeof descriptor !== \"object\" && typeof descriptor !== \"function\") || descriptor === null) {\n            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n        }\n        // make a valiant attempt to use the real defineProperty\n        // for I8\"s DOM elements.\n        if (definePropertyFallback) {\n            try {\n                return definePropertyFallback.call(Object, object, property, descriptor);\n            } catch (exception) {\n                // try the shim if the real one doesn't work\n            }\n        }\n\n        // If it\"s a data property.\n        if (\"value\" in descriptor) {\n\n            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {\n                // As accessors are supported only on engines implementing\n                // `__proto__` we can safely override `__proto__` while defining\n                // a property to make sure that we don\"t hit an inherited\n                // accessor.\n                /* jshint ignore:start */\n                var prototype = object.__proto__;\n                object.__proto__ = prototypeOfObject;\n                // Deleting a property anyway since getter / setter may be\n                // defined on object itself.\n                delete object[property];\n                object[property] = descriptor.value;\n                // Setting original `__proto__` back now.\n                object.__proto__ = prototype;\n                /* jshint ignore:end */\n            } else {\n                object[property] = descriptor.value;\n            }\n        } else {\n            if (!supportsAccessors && ((\"get\" in descriptor) || (\"set\" in descriptor))) {\n                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n            }\n            // If we got that far then getters and setters can be defined !!\n            if (\"get\" in descriptor) {\n                defineGetter(object, property, descriptor.get);\n            }\n            if (\"set\" in descriptor) {\n                defineSetter(object, property, descriptor.set);\n            }\n        }\n        return object;\n    };\n} else {\n    shim.object.defineProperty = Object.defineProperty;\n}\n\n// ES5 15.2.3.7\n// http://es5.github.com/#x15.2.3.7\nshim.object.defineProperties = Object.defineProperties && definePropertiesFallback && isFuncNative(Object.defineProperties) ?\n    Object.defineProperties :\n    function defineProperties(object, properties) {\n        // make a valiant attempt to use the real defineProperties\n        if (definePropertiesFallback) {\n            try {\n                return definePropertiesFallback.call(Object, object, properties);\n            } catch (exception) {\n                // try the shim if the real one doesn't work\n            }\n        }\n\n        array_forEach(shim.object.keys(properties), function (property) {\n            if (property !== \"__proto__\") {\n                shim.object.defineProperty(object, property, properties[property]);\n            }\n        });\n        return object;\n    };\n\n\n// ES5 15.2.3.8\n// http://es5.github.com/#x15.2.3.8\nshim.object.seal = Object.seal && isFuncNative(Object.seal) ? Object.seal :\n    function seal(object) {\n        if (toObject(object) !== object) {\n            throw new TypeError(\"Object.seal can only be called on Objects.\");\n        }\n        // this is misleading and breaks feature-detection, but\n        // allows \"securable\" code to \"gracefully\" degrade to working\n        // but insecure code.\n        return object;\n    };\n\n// ES5 15.2.3.9\n// http://es5.github.com/#x15.2.3.9\nshim.object.freeze = Object.freeze && isFuncNative(Object.freeze) ? Object.freeze :\n    function freeze(object) {\n        if (toObject(object) !== object) {\n            throw new TypeError(\"Object.freeze can only be called on Objects.\");\n        }\n        // this is misleading and breaks feature-detection, but\n        // allows \"securable\" code to \"gracefully\" degrade to working\n        // but insecure code.\n        return object;\n    };\n\n// detect a Rhino bug and patch it\ntry {\n    Object.freeze(function () {\n    });\n} catch (exception) {\n    shim.object.freeze = (function (freezeObject) {\n        return function freeze(object) {\n            if (typeof object === \"function\") {\n                return object;\n            } else {\n                return freezeObject(object);\n            }\n        };\n    }(shim.object.freeze));\n}\n\n// ES5 15.2.3.10\n// http://es5.github.com/#x15.2.3.10\nshim.object.preventExtensions = Object.preventExtensions && isFuncNative(Object.preventExtensions) ?\n    Object.preventExtensions : function preventExtensions(object) {\n    if (toObject(object) !== object) {\n        throw new TypeError(\"Object.preventExtensions can only be called on Objects.\");\n    }\n    // this is misleading and breaks feature-detection, but\n    // allows \"securable\" code to \"gracefully\" degrade to working\n    // but insecure code.\n    return object;\n};\n\nshim.object.isSealed = Object.isSealed && isFuncNative(Object.isSealed) ? Object.isSealed : function isSealed(object) {\n    if (toObject(object) !== object) {\n        throw new TypeError(\"Object.isSealed can only be called on Objects.\");\n    }\n    return false;\n};\n\n// ES5 15.2.3.12\n// http://es5.github.com/#x15.2.3.12\nshim.object.isFrozen = Object.isFrozen && isFuncNative(Object.isFrozen) ? Object.isFrozen : function isFrozen(object) {\n    if (toObject(object) !== object) {\n        throw new TypeError(\"Object.isFrozen can only be called on Objects.\");\n    }\n    return false;\n};\n\n// ES5 15.2.3.13\n// http://es5.github.com/#x15.2.3.13\nshim.object.isExtensible = Object.isExtensible && isFuncNative(Object.isExtensible) ? Object.isExtensible : function isExtensible(object) {\n    // 1. If Type(O) is not Object throw a TypeError exception.\n    if (toObject(object) !== object) {\n        throw new TypeError(\"Object.isExtensible can only be called on Objects.\");\n    }\n    // 2. Return the Boolean value of the [[Extensible]] internal property of O.\n    var name = \"\";\n    while (owns(object, name)) {\n        name += \"?\";\n    }\n    object[name] = true;\n    var returnValue = owns(object, name);\n    delete object[name];\n    return returnValue;\n};\n\n (function(exports, Object, _){\n\n\t var DependencyResolverException = function (message) {\n\t   this.name = \"DependencyResolverException\";\n\t   this.stack = null;\n\t   this.message = message || \"A dependency resolver exception has occurred.\";\n\t   var lines, i, tmp;\n\t   if ((typeof navigator !== \"undefined\" && navigator.userAgent.indexOf(\"Chrome\") !== -1) ||\n\t     (typeof navigator === \"undefined\")) {\n\t     lines = new Error().stack.split(\"\\n\");\n\t     if (lines && lines.length > 2) {\n\t       tmp = [];\n\t       for (i = 2; i < lines.length; i++) {\n\t         if (lines[i]) {\n\t           tmp.push(lines[i].trim());\n\t         }\n\t       }\n\t       this.stack = tmp.join(\"\\n\");\n\t     }\n\t   } else if (typeof navigator !== \"undefined\" && navigator.userAgent.indexOf(\"Firefox\") !== -1) {\n\t     lines = new Error().stack.split(\"\\n\");\n\t     if (lines && lines.length > 1) {\n\t       tmp = [];\n\t       for (i = 1; i < lines.length; i++) {\n\t         if (lines[i]) {\n\t           tmp.push(\"at \" + lines[i].trim().replace(\"@\", \" (\") + \")\");\n\t         }\n\t       }\n\t       this.stack = tmp.join(\"\\n\");\n\t     }\n\t   } else if (typeof navigator !== \"undefined\" && navigator.userAgent.indexOf(\"Trident\") !== -1) {\n\t     try {\n\t       throw new Error();\n\t     } catch (error) {\n\t       if (\"stack\" in error) {\n\t         lines = error.stack.split(\"\\n\");\n\t         if (lines && lines.length > 2) {\n\t           tmp = [];\n\t           for (i = 2; i < lines.length; i++) {\n\t             if (lines[i]) {\n\t               tmp.push(lines[i].trim());\n\t             }\n\t           }\n\t           this.stack = tmp.join(\"\\n\");\n\t         }\n\t       } else {\n\t         this.stack = \"\";\n\t       }\n\t     }\n\t   } else {\n\t     var error = new Error();\n\t     if (\"stack\" in error) {\n\t       this.stack = error.stack;\n\t     } else {\n\t       this.stack = \"\";\n\t     }\n\t   }\n\t   Object.defineProperty(this, \"name\", { enumerable: true });\n\t   Object.defineProperty(this, \"message\", { enumerable: true });\n\t   Object.defineProperty(this, \"stack\", { enumerable: true });\n\t   Object.seal(this);\n\t };\n\t \n\t DependencyResolverException.prototype = Object.create(Object.prototype, {\n\t   toString: {\n\t     value: function () {\n\t       var msg = this.name + \": \" + this.message;\n\t       if (this.stack) {\n\t         msg += \"\\n\\t\" + this.stack.replace(/\\n/g, \"\\n\\t\");\n\t       }\n\t       return msg;\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.seal(DependencyResolverException);\n\t Object.seal(DependencyResolverException.prototype);\n\t \n\t exports.DependencyResolverException = DependencyResolverException;\n\n\t /* global DependencyResolverException */\n\t var InstanceFactoryOptions = function (options) {\n\t   this.name = null;\n\t   this.type = null;\n\t   this.parameters = null;\n\t   if (options) {\n\t     for (var propertyName in options) {\n\t       if (propertyName in this) {\n\t         this[propertyName] = options[propertyName];\n\t       } else {\n\t         throw new DependencyResolverException(\"Class \\\"InstanceFactoryOptions\\\" doesn\\\"t have a property \\\"\" +\n\t           propertyName + \"\\\"\");\n\t       }\n\t     }\n\t   }\n\t   Object.defineProperty(this, \"name\", { enumerable: true });\n\t   Object.defineProperty(this, \"type\", { enumerable: true });\n\t   Object.defineProperty(this, \"parameters\", { enumerable: true });\n\t   Object.seal(this);\n\t };\n\t \n\t InstanceFactoryOptions.prototype = Object.create(Object.prototype, {\n\t   toString: {\n\t     value: function () {\n\t       return \"[object InstanceFactoryOptions]\";\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.seal(InstanceFactoryOptions);\n\t Object.seal(InstanceFactoryOptions.prototype);\n\t \n\t exports.InstanceFactoryOptions = InstanceFactoryOptions;\n\n\t \n\t var IInstanceFactory = Object.create(Object.prototype, {\n\t \n\t   create: {\n\t     value: function (options) {}, //eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   toString: {\n\t     value: function () {\n\t       return \"[object IInstanceFactory]\";\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.freeze(IInstanceFactory);\n\t \n\t exports.IInstanceFactory = IInstanceFactory;\n\n\t /* global DependencyResolverException */\n\t var InstanceFactory = function () {\n\t   Object.seal(this);\n\t };\n\t \n\t InstanceFactory.prototype = Object.create(Object.prototype, {\n\t \n\t   create: {\n\t     value: function (options) {\n\t       if (!options) {\n\t         throw new DependencyResolverException(\"Parameter \\\"options\\\" is not set\");\n\t       }\n\t       if (\"type\" in options && !options.type) {\n\t         throw new DependencyResolverException(\"Factory can't create object, because type is not set\");\n\t       }\n\t       if (typeof options.type !== \"function\") {\n\t         throw new DependencyResolverException(\"Factory can't create object, because given type is not a function\");\n\t       }\n\t       if (options.type === Number || options.type === Date || options.type === Boolean || options.type === String ||\n\t         options.type === Array || options.type === Function || options.type === RegExp) {\n\t         throw new DependencyResolverException(\"Basic type can not be instantiated using a factory\");\n\t       }\n\t       var instance = null;\n\t       if (options.parameters && options.parameters.length > 0) {\n\t         if(Function.prototype.bind){ // ES5\n\t           var ClassType = Function.bind.apply(options.type,[null].concat(options.parameters));\n\t           instance = new ClassType();\n\t         } else{ //ES3\n\t           instance = Object.create(options.type.prototype);\n\t           options.type.apply(instance, options.parameters);\n\t         }\n\t \n\t       } else {\n\t         instance = new options.type();\n\t       }\n\t       return instance;\n\t     },\n\t     enumerable: true\n\t   },\n\t \n\t   toString: {\n\t     value: function () {\n\t       return \"[object InstanceFactory]\";\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.seal(InstanceFactory);\n\t Object.seal(InstanceFactory.prototype);\n\t \n\t exports.InstanceFactory = InstanceFactory;\n\n\t var INameTransformer = Object.create(Object.prototype, {\n\t \n\t   transform: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   toString: {\n\t     value: function () {\n\t       return \"[object INameTransformer]\";\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.freeze(INameTransformer);\n\t \n\t exports.INameTransformer = INameTransformer;\n\n\t /* global DependencyResolverException */\n\t var NameTransformer = function () {\n\t   Object.seal(this);\n\t };\n\t \n\t NameTransformer.prototype = Object.create(Object.prototype, {\n\t \n\t   transform: {\n\t     value: function (name) {\n\t       if (!name) {\n\t         throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"transform\\\"\");\n\t       }\n\t       return name;\n\t     },\n\t     enumerable: true\n\t   },\n\t \n\t   toString: {\n\t     value: function () {\n\t       return \"[object NameTransformer]\";\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.seal(NameTransformer);\n\t Object.seal(NameTransformer.prototype);\n\t \n\t exports.NameTransformer = NameTransformer;\n\n\t var IDependencyResolver = Object.create(Object.prototype, {\n\t \n\t   isAutowired: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   autowired: {\n\t     value: function (value) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   register: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   as: {\n\t     value: function (type) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   instance: {\n\t     value: function (instance) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   asSingleton: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   withConstructor: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   param: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   withProperties: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   prop: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   val: {\n\t     value: function (instance) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   ref: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   setFactory: {\n\t     value: function (factory) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   create: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   inject: {\n\t     value: function (func, name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   contains: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   resolve: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   getDefaultFactory: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   setDefaultFactory: {\n\t     value: function (factory) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   getNameTransformer: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   setNameTransformer: {\n\t     value: function (transformer) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   getRegistration: {\n\t     value: function (name) {},//eslint-disable-line no-unused-vars\n\t     enumerable: true\n\t   },\n\t \n\t   dispose: {\n\t     value: function () {},\n\t     enumerable: true\n\t   },\n\t \n\t   toString: {\n\t     value: function () {\n\t       return \"[object IDependencyResolver]\";\n\t     },\n\t     enumerable: true\n\t   }\n\t \n\t });\n\t \n\t Object.freeze(IDependencyResolver);\n\t \n\t exports.IDependencyResolver = IDependencyResolver;\n\n\t /* global DependencyResolverException, InstanceFactory, NameTransformer, InstanceFactoryOptions, debug, index, args */\n\t var DependencyResolver = function (parent) {\n\t     this.__parent = parent;\n\t     this.__defaultFactory = null;\n\t     this.__nameTransformer = null;\n\t     this.__autowired = false;\n\t     this.__container = null;\n\t     this.__registration = null;\n\t     this.__withProperties = false;\n\t     this.__withConstructor = false;\n\t     this.__parameter = null;\n\t     this.__property = null;\n\t     this.__function = null;\n\t     if (parent) {\n\t         this.__autowired = parent.isAutowired();\n\t     }\n\t     Object.defineProperty(this, \"__parent\", {enumerable: false});\n\t     Object.defineProperty(this, \"__defaultFactory\", {enumerable: false});\n\t     Object.defineProperty(this, \"__nameTransformer\", {enumerable: false});\n\t     Object.defineProperty(this, \"__autowired\", {enumerable: false});\n\t     Object.defineProperty(this, \"__container\", {enumerable: false});\n\t     Object.defineProperty(this, \"__registration\", {enumerable: false});\n\t     Object.defineProperty(this, \"__withProperties\", {enumerable: false});\n\t     Object.defineProperty(this, \"__withConstructor\", {enumerable: false});\n\t     Object.defineProperty(this, \"__parameter\", {enumerable: false});\n\t     Object.defineProperty(this, \"__property\", {enumerable: false});\n\t     Object.defineProperty(this, \"__function\", {enumerable: false});\n\t     Object.seal(this);\n\t };\n\t \n\t DependencyResolver.prototype = Object.create(Object.prototype, {\n\t \n\t     isAutowired: {\n\t         value: function () {\n\t             return this.__autowired;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     autowired: {\n\t         value: function (value) {\n\t             if (value === undefined || value === null) {\n\t                 value = true;\n\t             }\n\t             if (typeof value !== \"boolean\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"value\\\" passed to the method \\\"autowired\\\" has to \" +\n\t                     \"be a \\\"boolean\\\"\");\n\t             }\n\t             this.__autowired = value;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     register: {\n\t         value: function (name) {\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"register\\\"\");\n\t             }\n\t             if (typeof name !== \"string\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"register\\\" has to be \" +\n\t                     \"a \\\"string\\\"\");\n\t             }\n\t             if (!this.__container) {\n\t                 this.__container = Object.create(null);\n\t             }\n\t             this.__registration = {\n\t                 name: name,\n\t                 singleton: false,\n\t                 type: null,\n\t                 instance: null,\n\t                 factory: null,\n\t                 dependencies: null\n\t             };\n\t             if (!(name in this.__container)) {\n\t                 this.__container[name] = this.__registration;\n\t             } else {\n\t                 if (!(this.__container[name] instanceof Array)) {\n\t                     this.__container[name] = [this.__container[name]];\n\t                 }\n\t                 this.__container[name].push(this.__registration);\n\t             }\n\t             this.__withConstructor = false;\n\t             this.__withProperties = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     as: {\n\t         value: function (type) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!type) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"type\\\" is not passed to the method \\\"as\\\" for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (typeof type !== \"function\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"type\\\" passed to the method \\\"as\\\" has to be a \\\"function\\\" \" +\n\t                     \"for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             this.__registration.instance = null;\n\t             this.__registration.type = type;\n\t             this.__registration.singleton = false;\n\t             this.__registration.dependencies = {\n\t                 parameters: [],\n\t                 properties: [],\n\t                 functions: []\n\t             };\n\t             if(type.$inject && type.$inject instanceof Array){\n\t                 this.__registration.dependencies.$inject = type.$inject;\n\t             }\n\t             this.__withConstructor = false;\n\t             this.__withProperties = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     instance: {\n\t         value: function (instance) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (instance === null || instance === undefined) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"instance\\\" is not passed to the method \\\"instance\\\" for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             this.__registration.instance = instance;\n\t             this.__registration.type = null;\n\t             this.__registration.factory = null;\n\t             this.__registration.singleton = true;\n\t             this.__registration.dependencies = null;\n\t             this.__withConstructor = false;\n\t             this.__withProperties = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     asSingleton: {\n\t         value: function () {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" +\n\t                     this.__registration.name + \"\\\"\");\n\t             }\n\t             this.__registration.singleton = true;\n\t             this.__withConstructor = false;\n\t             this.__withProperties = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     withConstructor: {\n\t         value: function () {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" +\n\t                     this.__registration.name + \"\\\"\");\n\t             }\n\t             this.__withConstructor = true;\n\t             this.__withProperties = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     param: {\n\t         value: function (name) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             var parameters = null,\n\t                 parameter = null,\n\t                 index;\n\t             if (this.__withConstructor) {\n\t                 parameters = this.__registration.dependencies.parameters;\n\t                 if (this.__autowired && (name === undefined || name === null)) {\n\t                     throw new DependencyResolverException(\"Parameter \\\"name\\\" has to be passed to the method, when dependency \" +\n\t                         \"container has option \\\"autowired\\\" enabled\");\n\t                 }\n\t                 parameter = this.__findParameter(name, parameters, this.__registration);\n\t             } else if (this.__withProperties) {\n\t                 if (!this.__function) {\n\t                     throw new DependencyResolverException(\"Function is not defined\");\n\t                 }\n\t                 parameters = this.__function.parameters;\n\t                 parameter = this.__findParameter(name, this.__function.parameters, this.__registration);\n\t             } else {\n\t                 throw new DependencyResolverException(\"Invocation of method \\\"withConstructor\\\" or \\\"withProperties\\\" \" +\n\t                     \"is missing for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (!parameter) {\n\t                 parameter = {\n\t                     index: index,\n\t                     name: name,\n\t                     value: undefined,\n\t                     reference: undefined\n\t                 };\n\t                 parameters.push(parameter);\n\t             }\n\t             this.__parameter = parameter;\n\t             this.__property = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     withProperties: {\n\t         value: function () {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             this.__withProperties = true;\n\t             this.__withConstructor = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     prop: {\n\t         value: function (name) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"prop\\\" for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (typeof name !== \"string\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"prop\\\" has to be\" +\n\t                     \" a \\\"string\\\" for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (!this.__withProperties) {\n\t                 throw new DependencyResolverException(\"Invocation of method \\\"withProperties\\\" is missing for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             var properties = this.__registration.dependencies.properties,\n\t                 property = null;\n\t             for (var i = 0; i < properties.length; i++) {\n\t                 if (properties[i].name === name) {\n\t                     property = properties[i];\n\t                     break;\n\t                 }\n\t             }\n\t             if (!property) {\n\t                 property = {\n\t                     name: name,\n\t                     value: undefined,\n\t                     reference: undefined\n\t                 };\n\t                 properties.push(property);\n\t             }\n\t             this.__parameter = null;\n\t             this.__property = property;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     func: {\n\t         value: function (name) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"func\\\" for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (typeof name !== \"string\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"func\\\" has to be\" +\n\t                     \" a \\\"string\\\" for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (!this.__withProperties) {\n\t                 throw new DependencyResolverException(\"Invocation of method \\\"withProperties\\\" is missing for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             var functions = this.__registration.dependencies.functions,\n\t                 func = null;\n\t             for (var i = 0; i < functions.length; i++) {\n\t                 if (functions[i].name === name) {\n\t                     func = functions[i];\n\t                     break;\n\t                 }\n\t             }\n\t             if (!func) {\n\t                 func = {\n\t                     name: name,\n\t                     parameters: []\n\t                 };\n\t                 functions.push(func);\n\t             }\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = func;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     val: {\n\t         value: function (instance) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (instance === null || instance === undefined) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"instance\\\" is not passed to the method \\\"val\\\"\");\n\t             }\n\t             if (!this.__withProperties && !this.__withConstructor) {\n\t                 throw new DependencyResolverException(\"Invocation of method withConstructor\\\" or \\\"withProperties\\\" \" +\n\t                     \"is missing\");\n\t             }\n\t             if (this.__withConstructor && !this.__parameter) {\n\t                 throw new DependencyResolverException(\"Parameter is not defined\");\n\t             }\n\t             if (this.__withProperties && !this.__parameter && !this.__property) {\n\t                 throw new DependencyResolverException(\"Parameter or property is not defined\");\n\t             }\n\t             if (this.__parameter) {\n\t                 this.__parameter.value = instance;\n\t                 this.__parameter.reference = undefined;\n\t             } else if (this.__property) {\n\t                 this.__property.value = instance;\n\t                 this.__property.reference = undefined;\n\t             }\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     ref: {\n\t         value: function (name) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"ref\\\" for \" +\n\t                     \"registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (typeof name !== \"string\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"ref\\\" has to \" +\n\t                     \"be a \\\"string\\\" for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (!this.__withProperties && !this.__withConstructor) {\n\t                 throw new DependencyResolverException(\"Invocation of method \\\"withConstructor\\\" or \\\"withProperties\\\" \" +\n\t                     \"is missing for registration \\\"\" + this.__registration.name + \"\\\"\");\n\t             }\n\t             if (this.__withConstructor && !this.__parameter) {\n\t                 throw new DependencyResolverException(\"Parameter is not defined\");\n\t             }\n\t             if (this.__withProperties && !this.__parameter && !this.__property) {\n\t                 throw new DependencyResolverException(\"Parameter or property is not defined\");\n\t             }\n\t             if (!this.contains(name)) {\n\t                 throw new DependencyResolverException(\"Type or instance is not registered with name \\\"\" + name + \"\\\"\");\n\t             }\n\t             if (this.__parameter) {\n\t                 this.__parameter.value = undefined;\n\t                 this.__parameter.reference = name;\n\t             } else if (this.__property) {\n\t                 this.__property.value = undefined;\n\t                 this.__property.reference = name;\n\t             }\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     setFactory: {\n\t         value: function (factory) {\n\t             if (!this.__registration) {\n\t                 throw new DependencyResolverException(\"Registration's name is not defined\");\n\t             }\n\t             if (!factory) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"factory\\\" is not passed to the method \\\"setFactory\\\"\");\n\t             }\n\t             if (typeof factory !== \"function\" && typeof factory !== \"object\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"factory\\\" passed to the method \\\"setFactory\\\" has to be \" +\n\t                     \"a \\\"function\\\" or \\\"object\\\"\");\n\t             }\n\t             if (typeof factory === \"object\" && !(\"create\" in factory)) {\n\t                 throw new DependencyResolverException(\"Factory's instance passed to the method \\\"setFactory\\\" has to have \" +\n\t                     \"a method \\\"create\\\"\");\n\t             }\n\t             if (!this.__registration.type) {\n\t                 throw new DependencyResolverException(\"Type is not set for registration \\\"\" + this.__registration.name);\n\t             }\n\t             this.__registration.factory = factory;\n\t             this.__withConstructor = false;\n\t             this.__withProperties = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     create: {\n\t         value: function () {\n\t             return new DependencyResolver(this);\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     inject: {\n\t         value: function (func) {\n\t             if (!func) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"func\\\" is not passed to method \\\"inject\\\"\");\n\t             }\n\t             var i,\n\t                 parameters = [],\n\t                 context = {resolving: []};\n\t             if (func instanceof Array) {\n\t                 if (func.length === 0) {\n\t                     throw new DependencyResolverException(\"The array passed to the method \\\"inject\\\" can't be empty\");\n\t                 }\n\t                 for (i = 0; i < func.length - 1; i++) {\n\t                     parameters.push(func[i]);\n\t                 }\n\t                 func = func[func.length - 1];\n\t                 if (typeof func !== \"function\") {\n\t                     throw new DependencyResolverException(\"The last item of the array passed to the method \\\"inject\\\" has \" +\n\t                         \"to be a \\\"function\\\"\");\n\t                 }\n\t                 for (i = 0; i < parameters.length; i++) {\n\t                     if (typeof parameters[i] === \"string\" && this.contains(parameters[i])) {\n\t                         parameters[i] = this.__resolve(parameters[i], context);\n\t                     }\n\t                 }\n\t                 func.apply(null, parameters);\n\t             } else {\n\t                 var registration = null;\n\t                 if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n\t                     var name = arguments[1];\n\t                     if (!this.contains(name)) {\n\t                         throw new DependencyResolverException(\"Type with name \\\"\" + name + \"\\\" is not registered\");\n\t                     }\n\t                     registration = this.getRegistration(name);\n\t                 }\n\t                 var dependencyName;\n\t                 if (typeof func === \"function\") {\n\t                     if (registration) {\n\t                         parameters = this.__getConstructorParameters(registration, context);\n\t                     } else {\n\t                         var args = this.__getFunctionArguments(func);\n\t                         for (i = 0; i < args.length; i++) {\n\t                             dependencyName = this.__resolveDependencyName(args[i]);\n\t                             if (this.contains(dependencyName)) {\n\t                                 parameters.push(this.__resolve(dependencyName, context));\n\t                             } else {\n\t                                 parameters.push(null);\n\t                             }\n\t                         }\n\t                     }\n\t                     func.apply(null, parameters);\n\t                 } else if (typeof func === \"object\") {\n\t                     if (registration) {\n\t                         this.__setProperties(func, registration, context);\n\t                         this.__invokeFunctions(func, registration, context);\n\t                     } else {\n\t                         for (var propertyName in func) {//eslint-disable-line guard-for-in\n\t                             dependencyName = this.__resolveDependencyName(propertyName);\n\t                             if (this.contains(dependencyName)) {\n\t                                 parameters.push({\n\t                                     name: propertyName,\n\t                                     value: this.__resolve(dependencyName, context)\n\t                                 });\n\t                             }\n\t                         }\n\t                         if (parameters.length > 0) {\n\t                             for (i = 0; i < parameters.length; i++) {\n\t                                 func[parameters[i].name] = parameters[i].value;\n\t                             }\n\t                         }\n\t                     }\n\t                 } else {\n\t                     throw new DependencyResolverException(\"Invalid parameter has been passed to the method \\\"inject\\\"\");\n\t                 }\n\t             }\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     contains: {\n\t         value: function (name) {\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"contains\\\"\");\n\t             }\n\t             if (typeof name !== \"string\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the  has to be a \\\"string\\\"\");\n\t             }\n\t             var has = false;\n\t             if (this.__container) {\n\t                 if (name in this.__container) {\n\t                     has = true;\n\t                 }\n\t             }\n\t             if (!has && this.__parent) {\n\t                 if (!(\"contains\" in this.__parent)) {\n\t                     throw new DependencyResolverException(\"Dependency resolver's parent doesn't have a method \\\"contains\\\"\");\n\t                 }\n\t                 has = this.__parent.contains(name);\n\t             }\n\t             return has;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     resolve: {\n\t         value: function (name) {\n\t             return this.__resolve(name, {\n\t                 resolving: []\n\t             });\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     getDefaultFactory: {\n\t         value: function () {\n\t             var factory = null;\n\t             if (this.__defaultFactory) {\n\t                 factory = this.__defaultFactory;\n\t             } else if (this.__parent) {\n\t                 if (!(\"getDefaultFactory\" in this.__parent)) {\n\t                     throw new DependencyResolverException(\"Dependency resolver's parent doesn't have a \" +\n\t                         \"method \\\"getDefaultFactory\\\"\");\n\t                 }\n\t                 factory = this.__parent.getDefaultFactory();\n\t             } else {\n\t                 factory = new InstanceFactory();\n\t             }\n\t             return factory;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     setDefaultFactory: {\n\t         value: function (factory) {\n\t             if (!factory) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"factory\\\" is not passed to the method \" +\n\t                     \"\\\"setDefaultFactory\\\"\");\n\t             }\n\t             if (typeof factory !== \"function\" && typeof factory !== \"object\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"factory\\\" passed to the method \\\"setDefaultFactory\\\" has \" +\n\t                     \" to be a \\\"function\\\" or \\\"object\\\"\");\n\t             }\n\t             if (typeof factory === \"object\" && !(\"create\" in factory)) {\n\t                 throw new DependencyResolverException(\"Factory's instance passed to the method \\\"setDefaultFactory\\\" has \" +\n\t                     \"to have a method \\\"create\\\"\");\n\t             }\n\t             this.__defaultFactory = factory;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     getNameTransformer: {\n\t         value: function () {\n\t             var transformer = null;\n\t             if (this.__nameTransformer) {\n\t                 transformer = this.__nameTransformer;\n\t             } else if (this.__parent) {\n\t                 if (!(\"getNameTransformer\" in this.__parent)) {\n\t                     throw new DependencyResolverException(\"Dependency resolver's parent doesn't have a \" +\n\t                         \"method \\\"getNameTransformer\\\"\");\n\t                 }\n\t                 transformer = this.__parent.getNameTransformer();\n\t             } else {\n\t                 transformer = new NameTransformer();\n\t             }\n\t             return transformer;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     setNameTransformer: {\n\t         value: function (transformer) {\n\t             if (!transformer) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"transformer\\\" is not passed to the method \" +\n\t                     \"\\\"setNameTransformer\\\"\");\n\t             }\n\t             if (typeof transformer !== \"function\" && typeof transformer !== \"object\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"transformer\\\" passed to the method \\\"setNameTransformer\\\" \" +\n\t                     \"has to be a \\\"function\\\" or \\\"object\\\"\");\n\t             }\n\t             if (typeof transformer === \"object\" && !(\"transform\" in transformer)) {\n\t                 throw new DependencyResolverException(\"Transformers's instance passed to the method \\\"setNameTransformer\\\" \" +\n\t                     \"has to have a method \\\"transform\\\"\");\n\t             }\n\t             this.__nameTransformer = transformer;\n\t             return this;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     getRegistration: {\n\t         value: function (name) {\n\t             var registration = null;\n\t             if (this.__container && name in this.__container) {\n\t                 registration = this.__container[name];\n\t             } else if (this.__parent) {\n\t                 if (!(\"getRegistration\" in this.__parent)) {\n\t                     throw new DependencyResolverException(\"Dependency resolver\\\"s parent doesn't have a \" +\n\t                         \"method \\\"getRegistration\\\"\");\n\t                 }\n\t                 registration = this.__parent.getRegistration(name);\n\t             }\n\t             return registration;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     dispose: {\n\t         value: function () {\n\t             var registration = null,\n\t                 i = 0;\n\t             if (this.__container) {\n\t                 for (var name in this.__container) {\n\t                     if (!(this.__container[name] instanceof Array)) {\n\t                         registration = this.__container[name];\n\t                         if (registration.instance && (\"dispose\" in registration.instance)) {\n\t                             registration.instance.dispose();\n\t                         }\n\t                         registration.instance = null;\n\t                         registration.factory = null;\n\t                     } else {\n\t                         var registrations = this.__container[name];\n\t                         for (i = 0; i < registrations.length; i++) {\n\t                             registration = registrations[i];\n\t                             if (registration.instance && (\"dispose\" in registration.instance)) {\n\t                                 registration.instance.dispose();\n\t                             }\n\t                             registration.instance = null;\n\t                             registration.factory = null;\n\t                         }\n\t                     }\n\t                 }\n\t             }\n\t             this.__parent = null;\n\t             this.__defaultFactory = null;\n\t             this.__nameTransformer = null;\n\t             this.__autowired = false;\n\t             this.__container = null;\n\t             this.__registration = null;\n\t             this.__withProperties = false;\n\t             this.__withConstructor = false;\n\t             this.__parameter = null;\n\t             this.__property = null;\n\t             this.__function = null;\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     toString: {\n\t         value: function () {\n\t             return \"[object DependencyResolver]\";\n\t         },\n\t         enumerable: true\n\t     },\n\t \n\t     __getFunctionArguments: {\n\t         value: function (func) {\n\t             if (func && typeof func === \"function\" && \"toString\" in func) {\n\t                 var str = null;\n\t                 var result = _.function_toString.call(func)\n\t                     .match(/^[\\s\\(]*function[^(]*\\(([^)]*)\\)/);\n\t                 if (result && result.length > 1) {\n\t                     str = result[1]\n\t                         .replace(/\\/\\/.*?[\\r\\n]|\\/\\*(?:.|[\\r\\n])*?\\*\\//g, \"\")\n\t                         .replace(/\\s+/g, \"\");\n\t                 }\n\t                 if (str) {\n\t                     return str.split(\",\");\n\t                 }\n\t             }\n\t             return [];\n\t         }\n\t     },\n\t \n\t     __isClass: {\n\t         value: function (func) {\n\t             return func && typeof func === 'function' && 'toString' in func\n\t                 && /^class\\s/.test(func.toString());\n\t         }\n\t     },\n\t \n\t     __getClassConstructorArguments: {\n\t         value: function (constr) {\n\t             if (constr && typeof constr === 'function' && 'toString' in constr) {\n\t                 var str = null;\n\t                 var result = constr\n\t                     .toString()\n\t                     .match(/^class[\\s\\S]*constructor[\\s]*\\(([^)]*)\\)/);\n\t                 if (result && result.length > 1) {\n\t                     str = result[1]\n\t                         .replace(/\\/\\/.*?[\\r\\n]|\\/\\*(?:.|[\\r\\n])*?\\*\\//g, '')\n\t                         .replace(/\\s+/g, '');\n\t                 }\n\t                 if (str) {\n\t                     return str.split(',');\n\t                 }\n\t             }\n\t             return [];\n\t         }\n\t     },\n\t \n\t     __resolve: {\n\t         value: function (name, context) {\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" is not passed to the method \\\"resolve\\\"\");\n\t             }\n\t             if (typeof name !== \"string\") {\n\t                 throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"resolve\\\" has to be \" +\n\t                     \"a \\\"string\\\"\");\n\t             }\n\t             if (debug && console && \"log\" in console) {\n\t                 var message = \"-> \\\"\" + name + \"\\\"\";\n\t                 for (var j = 0; j < context.resolving.length; j++) {\n\t                     message = \"  \" + message;\n\t                 }\n\t                 console.log(message);\n\t             }\n\t             if (!this.contains(name)) {\n\t                 throw new DependencyResolverException(\"Type or instance with name \\\"\" + name + \"\\\" is not registered\");\n\t             }\n\t             var index = _.indexOf(context.resolving, name);\n\t             if (index !== -1) {\n\t                 throw new DependencyResolverException(\"Can not resolve circular dependency \\\"\" + name + \"\\\"\");\n\t             }\n\t             context.resolving.push(name);\n\t             var instance = null,\n\t                 registration = this.getRegistration(name);\n\t             if (!(registration instanceof Array)) {\n\t                 instance = this.__resolveInstance(registration, context);\n\t             } else {\n\t                 instance = [];\n\t                 for (var i = 0; i < registration.length; i++) {\n\t                     instance.push(this.__resolveInstance(registration[i], context));\n\t                 }\n\t             }\n\t             index = _.indexOf(context.resolving, name);\n\t             if (index > -1) {\n\t                 context.resolving.splice(index, 1);\n\t             }\n\t             return instance;\n\t         }\n\t     },\n\t \n\t     __resolveInstance: {\n\t         value: function (registration, context) {\n\t             var instance = null;\n\t             if (registration.instance !== null && registration.instance !== undefined) {\n\t                 instance = registration.instance;\n\t             } else {\n\t                 instance = this.__createInstance(registration, context);\n\t                 this.__setProperties(instance, registration, context);\n\t                 this.__invokeFunctions(instance, registration, context);\n\t                 if (instance && registration.singleton) {\n\t                     registration.instance = instance;\n\t                 }\n\t                 if (!instance) {\n\t                     throw new DependencyResolverException(\"Failed to resolve instance by name \\\"\" + registration.name + \"\\\"\");\n\t                 }\n\t             }\n\t             return instance;\n\t         }\n\t     },\n\t \n\t     __resolveDependencyName: {\n\t         value: function (name) {\n\t             var transform = this.getNameTransformer();\n\t             if (typeof transform === \"function\") {\n\t                 name = transform(name);\n\t             } else {\n\t                 name = transform.transform(name);\n\t             }\n\t             if (!name) {\n\t                 throw new DependencyResolverException(\"Failed to resolve dependency name\");\n\t             }\n\t             return name;\n\t         }\n\t     },\n\t \n\t     __createInstance: {\n\t         value: function (registration, context) {\n\t             var i,//eslint-disable-line no-unused-vars\n\t                 instance;\n\t             var parameters = this.__getConstructorParameters(registration, context);\n\t             var options = new InstanceFactoryOptions({\n\t                 name: registration.name,\n\t                 type: registration.type,\n\t                 parameters: parameters\n\t             });\n\t             var factory = null;\n\t             if (registration.factory) {\n\t                 factory = registration.factory;\n\t             } else {\n\t                 factory = this.getDefaultFactory();\n\t             }\n\t             if (factory) {\n\t                 if (typeof factory === \"function\") {\n\t                     instance = factory.call(null, options);\n\t                 } else {\n\t                     instance = factory.create(options);\n\t                 }\n\t             } else {\n\t                 throw new DependencyResolverException(\"Default factory is not defined\");\n\t             }\n\t             return instance;\n\t         }\n\t     },\n\t \n\t     __getConstructorParameters: {\n\t         value: function (registration, context) {\n\t             var parameters = [];\n\t             if (registration && registration.dependencies) {\n\t                 var i,\n\t                     parameter,\n\t                     value,\n\t                     args,\n\t                     index;\n\t                 if (this.__autowired) {\n\t                     args = this.__isClass(registration.type) ?\n\t                         this.__getClassConstructorArguments(registration.type) : this.__getFunctionArguments(registration.type);\n\t                     if(registration.dependencies.$inject){\n\t                         if(registration.dependencies.$inject.length !== args.length){\n\t                             throw new DependencyResolverException(\"Constructor in registration \\\"\" + registration.name +\n\t                                 \"\\\" have $inject property with wrong arguments length.\");\n\t                         }\n\t                         args = registration.dependencies.$inject;\n\t                     }\n\t                     var dependencyName;\n\t                     for (i = 0; i < args.length; i++) {\n\t                         dependencyName = this.__resolveDependencyName(args[i]);\n\t                         if (this.contains(dependencyName)) {\n\t                             parameters.push(this.__resolve(dependencyName, context));\n\t                         } else {\n\t                             parameters.push(null);\n\t                         }\n\t                     }\n\t                 }\n\t                 for (i = 0; i < registration.dependencies.parameters.length; i++) {\n\t                     parameter = registration.dependencies.parameters[i];\n\t                     if (parameter.value !== undefined) {\n\t                         value = parameter.value;\n\t                     } else if (parameter.reference !== undefined) {\n\t                         value = this.__resolve(parameter.reference, context);\n\t                     } else {\n\t                         value = null;\n\t                     }\n\t                     if (parameter.index !== undefined && parameter.index !== null) {\n\t                         parameters[parameter.index] = value;\n\t                     } else if (parameter.name) {\n\t                         if (!args) {\n\t                             args = this.__getFunctionArguments(registration.type);\n\t                         }\n\t                         index = _.indexOf(args, parameter.name);\n\t                         if (index === -1) {\n\t                             throw new DependencyResolverException(\"Constructor in registration \\\"\" + registration.name +\n\t                                 \"\\\" doesn't have defined parameter \\\"\" + parameter.name + \"\\\"\");\n\t                         }\n\t                         parameters[index] = value;\n\t                     } else {\n\t                         parameters.push(value);\n\t                     }\n\t                 }\n\t             }\n\t             return parameters;\n\t         }\n\t     },\n\t \n\t     __hasProperty: {\n\t         value: function (registration, name) {\n\t             var has = false;\n\t             if (registration.dependencies) {\n\t                 var property;\n\t                 for (var i = 0; i < registration.dependencies.properties.length; i++) {\n\t                     property = registration.dependencies.properties[i];\n\t                     if (property.name === name) {\n\t                         has = true;\n\t                         break;\n\t                     }\n\t                 }\n\t             }\n\t             return has;\n\t         }\n\t     },\n\t \n\t     __findParameter: {\n\t         value: function (name, parameters, registration) {\n\t             var parameter = null;\n\t             if (name !== null && name !== undefined && registration !== null) {\n\t                 if (typeof name === \"number\") {\n\t                     index = name;\n\t                     name = undefined;\n\t                     if (index < 0) {\n\t                         throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"param\\\" is out of \" +\n\t                             \"range for registration \\\"\" + registration.name + \"\\\"\");\n\t                     }\n\t                     if (index < parameters.length) {\n\t                         parameter = parameters[index];\n\t                     }\n\t                 } else if (typeof name === \"string\") {\n\t                     for (var i = 0; i < parameters.length; i++) {\n\t                         if (parameters[i].name === name) {\n\t                             parameter = parameters[i];\n\t                             break;\n\t                         }\n\t                     }\n\t                 } else {\n\t                     throw new DependencyResolverException(\"Parameter \\\"name\\\" passed to the method \\\"param\\\" has to \" +\n\t                         \"be a \\\"number\\\" or a \\\"string\\\" for registration \\\"\" + registration.name + \"\\\"\");\n\t                 }\n\t             }\n\t             return parameter;\n\t         }\n\t     },\n\t \n\t     __setProperties: {\n\t         value: function (instance, registration, context) {\n\t             if (registration.dependencies) {\n\t                 if (this.__autowired) {\n\t                     for (var propertyName in instance) {//eslint-disable-line guard-for-in\n\t                         if (propertyName === \"__proto__\") {\n\t                             continue;\n\t                         }\n\t                         var dependencyName = this.__resolveDependencyName(propertyName);\n\t                         if (!this.__hasProperty(registration, propertyName) && this.contains(dependencyName)) {\n\t                             instance[propertyName] = this.__resolve(dependencyName, context);\n\t                         }\n\t                     }\n\t                 }\n\t                 for (var i = 0; i < registration.dependencies.properties.length; i++) {\n\t                     var property = registration.dependencies.properties[i];\n\t                     if (!(property.name in instance)) {\n\t                         throw new DependencyResolverException(\"Resolved object \\\"\" + registration.name +\n\t                             \"\\\" doesn't have property \\\"\" + property.name + \"\\\"\");\n\t                     }\n\t                     if (property.value !== undefined) {\n\t                         instance[property.name] = property.value;\n\t                     } else if (property.reference !== undefined) {\n\t                         instance[property.name] = this.__resolve(property.reference, context);\n\t                     }\n\t                 }\n\t             }\n\t         }\n\t     },\n\t \n\t     __invokeFunctions: {\n\t         value: function (instance, registration, context) {\n\t             if (registration.dependencies) {\n\t                 var i,\n\t                     j,\n\t                     parameter,\n\t                     value;\n\t                 for (i = 0; i < registration.dependencies.functions.length; i++) {\n\t                     var func = registration.dependencies.functions[i];\n\t                     if (!(func.name in instance)) {\n\t                         throw new DependencyResolverException(\"Resolved object \\\"\" + registration.name +\n\t                             \"\\\" doesn't have function \\\"\" + func.name + \"\\\"\");\n\t                     }\n\t                     var parameters = [];\n\t                     for (j = 0; j < func.parameters.length; j++) {\n\t                         parameter = func.parameters[j];\n\t                         if (parameter.value !== undefined) {\n\t                             value = parameter.value;\n\t                         } else if (parameter.reference !== undefined) {\n\t                             value = this.__resolve(parameter.reference, context);\n\t                         } else {\n\t                             value = null;\n\t                         }\n\t                         if (parameter.index !== undefined && parameter.index !== null) {\n\t                             parameters[parameter.index] = value;\n\t                         } else if (parameter.name) {\n\t                             if (!args) {\n\t                                 args = this.__getFunctionArguments(instance[func.name]);//eslint-disable-line\n\t                             }\n\t                             index = _.indexOf(args, parameter.name);\n\t                             if (index === -1) {\n\t                                 throw new DependencyResolverException(\"Function doesn't have defined parameter \\\"\" +\n\t                                     parameter.name + \"\\\"\");\n\t                             }\n\t                             parameters[index] = value;\n\t                         } else {\n\t                             parameters.push(value);\n\t                         }\n\t                     }\n\t                     instance[func.name].apply(instance, parameters);\n\t                 }\n\t             }\n\t         }\n\t     }\n\t \n\t });\n\t \n\t Object.seal(DependencyResolver);\n\t Object.seal(DependencyResolver.prototype);\n\t \n\t exports.DependencyResolver = DependencyResolver;\n\n\t /* global DependencyResolver*/\n\t var defaultDependencyResolver = null,\n\t     debug = false;\n\t \n\t Object.defineProperty(exports, \"getDefaultDependencyResolver\", {\n\t   value: function () {\n\t     if (!defaultDependencyResolver) {\n\t       defaultDependencyResolver = new DependencyResolver();\n\t     }\n\t     return defaultDependencyResolver;\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"setDefaultDependencyResolver\", {\n\t   value: function (value) {\n\t     defaultDependencyResolver = value;\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"isAutowired\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .isAutowired();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"autowired\", {\n\t   value: function (value) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .autowired(value);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"register\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .register(name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"as\", {\n\t   value: function (type) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .as(type);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"instance\", {\n\t   value: function (instance) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .instance(instance);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"asSingleton\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .asSingleton();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"withConstructor\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .withConstructor();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"param\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .param(name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"withProperties\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .withProperties();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"prop\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .prop(name);\n\t   }\n\t });\n\t \n\t Object.defineProperty(exports, \"func\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .func(name);\n\t   }\n\t });\n\t \n\t Object.defineProperty(exports, \"val\", {\n\t   value: function (instance) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .val(instance);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"ref\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .ref(name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"setFactory\", {\n\t   value: function (factory) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .setFactory(factory);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"create\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .create();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"inject\", {\n\t   value: function (func, name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .inject(func, name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"contains\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .contains(name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"resolve\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .resolve(name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"getDefaultFactory\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .getDefaultFactory();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"setDefaultFactory\", {\n\t   value: function (factory) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .setDefaultFactory(factory);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"getNameTransformer\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .getNameTransformer();\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"setNameTransformer\", {\n\t   value: function (transformer) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .setNameTransformer(transformer);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"getRegistration\", {\n\t   value: function (name) {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .getRegistration(name);\n\t   },\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"debug\", {\n\t   value:debug,\n\t   enumerable: true\n\t });\n\t \n\t Object.defineProperty(exports, \"dispose\", {\n\t   value: function () {\n\t     return exports\n\t       .getDefaultDependencyResolver()\n\t       .dispose();\n\t   },\n\t   enumerable: true\n\t });\n\n\t var\n\t \t// Map over the di in case of overwrite\n\t \t_di = window.di;\n\t \n\t exports.noConflict = function () {\n\t     if (window.di === exports) {\n\t         window.di = _di;\n\t     }\n\t \n\t     return exports;\n\t };\n\t \n\n\t} (exports, shim.object, shim._));\n\n window.di = exports;\n\n} ());\n\n"],"file":"di4es.js"}